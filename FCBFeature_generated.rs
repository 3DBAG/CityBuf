// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod flat_citybuf {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_COLUMN_TYPE: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_COLUMN_TYPE: u8 = 14;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_COLUMN_TYPE: [ColumnType; 15] = [
  ColumnType::Byte,
  ColumnType::UByte,
  ColumnType::Bool,
  ColumnType::Short,
  ColumnType::UShort,
  ColumnType::Int,
  ColumnType::UInt,
  ColumnType::Long,
  ColumnType::ULong,
  ColumnType::Float,
  ColumnType::Double,
  ColumnType::String,
  ColumnType::Json,
  ColumnType::DateTime,
  ColumnType::Binary,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ColumnType(pub u8);
#[allow(non_upper_case_globals)]
impl ColumnType {
  pub const Byte: Self = Self(0);
  pub const UByte: Self = Self(1);
  pub const Bool: Self = Self(2);
  pub const Short: Self = Self(3);
  pub const UShort: Self = Self(4);
  pub const Int: Self = Self(5);
  pub const UInt: Self = Self(6);
  pub const Long: Self = Self(7);
  pub const ULong: Self = Self(8);
  pub const Float: Self = Self(9);
  pub const Double: Self = Self(10);
  pub const String: Self = Self(11);
  pub const Json: Self = Self(12);
  pub const DateTime: Self = Self(13);
  pub const Binary: Self = Self(14);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 14;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Byte,
    Self::UByte,
    Self::Bool,
    Self::Short,
    Self::UShort,
    Self::Int,
    Self::UInt,
    Self::Long,
    Self::ULong,
    Self::Float,
    Self::Double,
    Self::String,
    Self::Json,
    Self::DateTime,
    Self::Binary,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Byte => Some("Byte"),
      Self::UByte => Some("UByte"),
      Self::Bool => Some("Bool"),
      Self::Short => Some("Short"),
      Self::UShort => Some("UShort"),
      Self::Int => Some("Int"),
      Self::UInt => Some("UInt"),
      Self::Long => Some("Long"),
      Self::ULong => Some("ULong"),
      Self::Float => Some("Float"),
      Self::Double => Some("Double"),
      Self::String => Some("String"),
      Self::Json => Some("Json"),
      Self::DateTime => Some("DateTime"),
      Self::Binary => Some("Binary"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for ColumnType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for ColumnType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for ColumnType {
    type Output = ColumnType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for ColumnType {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for ColumnType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ColumnType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_CITY_OBJECT_TYPE: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_CITY_OBJECT_TYPE: u8 = 13;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_CITY_OBJECT_TYPE: [CityObjectType; 14] = [
  CityObjectType::Bridge,
  CityObjectType::Building,
  CityObjectType::BuildingPart,
  CityObjectType::CityFurniture,
  CityObjectType::CityObjectGroup,
  CityObjectType::GenericCityObject,
  CityObjectType::LandUse,
  CityObjectType::OtherConstruction,
  CityObjectType::PlantCover,
  CityObjectType::SolitaryVegetationObject,
  CityObjectType::TINRelief,
  CityObjectType::Transportation,
  CityObjectType::Tunnel,
  CityObjectType::WaterBody,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct CityObjectType(pub u8);
#[allow(non_upper_case_globals)]
impl CityObjectType {
  pub const Bridge: Self = Self(0);
  pub const Building: Self = Self(1);
  pub const BuildingPart: Self = Self(2);
  pub const CityFurniture: Self = Self(3);
  pub const CityObjectGroup: Self = Self(4);
  pub const GenericCityObject: Self = Self(5);
  pub const LandUse: Self = Self(6);
  pub const OtherConstruction: Self = Self(7);
  pub const PlantCover: Self = Self(8);
  pub const SolitaryVegetationObject: Self = Self(9);
  pub const TINRelief: Self = Self(10);
  pub const Transportation: Self = Self(11);
  pub const Tunnel: Self = Self(12);
  pub const WaterBody: Self = Self(13);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 13;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Bridge,
    Self::Building,
    Self::BuildingPart,
    Self::CityFurniture,
    Self::CityObjectGroup,
    Self::GenericCityObject,
    Self::LandUse,
    Self::OtherConstruction,
    Self::PlantCover,
    Self::SolitaryVegetationObject,
    Self::TINRelief,
    Self::Transportation,
    Self::Tunnel,
    Self::WaterBody,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Bridge => Some("Bridge"),
      Self::Building => Some("Building"),
      Self::BuildingPart => Some("BuildingPart"),
      Self::CityFurniture => Some("CityFurniture"),
      Self::CityObjectGroup => Some("CityObjectGroup"),
      Self::GenericCityObject => Some("GenericCityObject"),
      Self::LandUse => Some("LandUse"),
      Self::OtherConstruction => Some("OtherConstruction"),
      Self::PlantCover => Some("PlantCover"),
      Self::SolitaryVegetationObject => Some("SolitaryVegetationObject"),
      Self::TINRelief => Some("TINRelief"),
      Self::Transportation => Some("Transportation"),
      Self::Tunnel => Some("Tunnel"),
      Self::WaterBody => Some("WaterBody"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for CityObjectType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for CityObjectType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for CityObjectType {
    type Output = CityObjectType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for CityObjectType {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for CityObjectType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for CityObjectType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_SEMANTIC_SURFACE_TYPE: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_SEMANTIC_SURFACE_TYPE: u8 = 17;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_SEMANTIC_SURFACE_TYPE: [SemanticSurfaceType; 18] = [
  SemanticSurfaceType::RoofSurface,
  SemanticSurfaceType::GroundSurface,
  SemanticSurfaceType::WallSurface,
  SemanticSurfaceType::ClosureSurface,
  SemanticSurfaceType::OuterCeilingSurface,
  SemanticSurfaceType::OuterFloorSurface,
  SemanticSurfaceType::Window,
  SemanticSurfaceType::Door,
  SemanticSurfaceType::InteriorWallSurface,
  SemanticSurfaceType::CeilingSurface,
  SemanticSurfaceType::FloorSurface,
  SemanticSurfaceType::WaterSurface,
  SemanticSurfaceType::WaterGroundSurface,
  SemanticSurfaceType::WaterClosureSurface,
  SemanticSurfaceType::TrafficArea,
  SemanticSurfaceType::AuxiliaryTrafficArea,
  SemanticSurfaceType::TransportationMarking,
  SemanticSurfaceType::TransportationHole,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct SemanticSurfaceType(pub u8);
#[allow(non_upper_case_globals)]
impl SemanticSurfaceType {
  pub const RoofSurface: Self = Self(0);
  pub const GroundSurface: Self = Self(1);
  pub const WallSurface: Self = Self(2);
  pub const ClosureSurface: Self = Self(3);
  pub const OuterCeilingSurface: Self = Self(4);
  pub const OuterFloorSurface: Self = Self(5);
  pub const Window: Self = Self(6);
  pub const Door: Self = Self(7);
  pub const InteriorWallSurface: Self = Self(8);
  pub const CeilingSurface: Self = Self(9);
  pub const FloorSurface: Self = Self(10);
  pub const WaterSurface: Self = Self(11);
  pub const WaterGroundSurface: Self = Self(12);
  pub const WaterClosureSurface: Self = Self(13);
  pub const TrafficArea: Self = Self(14);
  pub const AuxiliaryTrafficArea: Self = Self(15);
  pub const TransportationMarking: Self = Self(16);
  pub const TransportationHole: Self = Self(17);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 17;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::RoofSurface,
    Self::GroundSurface,
    Self::WallSurface,
    Self::ClosureSurface,
    Self::OuterCeilingSurface,
    Self::OuterFloorSurface,
    Self::Window,
    Self::Door,
    Self::InteriorWallSurface,
    Self::CeilingSurface,
    Self::FloorSurface,
    Self::WaterSurface,
    Self::WaterGroundSurface,
    Self::WaterClosureSurface,
    Self::TrafficArea,
    Self::AuxiliaryTrafficArea,
    Self::TransportationMarking,
    Self::TransportationHole,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::RoofSurface => Some("RoofSurface"),
      Self::GroundSurface => Some("GroundSurface"),
      Self::WallSurface => Some("WallSurface"),
      Self::ClosureSurface => Some("ClosureSurface"),
      Self::OuterCeilingSurface => Some("OuterCeilingSurface"),
      Self::OuterFloorSurface => Some("OuterFloorSurface"),
      Self::Window => Some("Window"),
      Self::Door => Some("Door"),
      Self::InteriorWallSurface => Some("InteriorWallSurface"),
      Self::CeilingSurface => Some("CeilingSurface"),
      Self::FloorSurface => Some("FloorSurface"),
      Self::WaterSurface => Some("WaterSurface"),
      Self::WaterGroundSurface => Some("WaterGroundSurface"),
      Self::WaterClosureSurface => Some("WaterClosureSurface"),
      Self::TrafficArea => Some("TrafficArea"),
      Self::AuxiliaryTrafficArea => Some("AuxiliaryTrafficArea"),
      Self::TransportationMarking => Some("TransportationMarking"),
      Self::TransportationHole => Some("TransportationHole"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for SemanticSurfaceType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for SemanticSurfaceType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for SemanticSurfaceType {
    type Output = SemanticSurfaceType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for SemanticSurfaceType {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for SemanticSurfaceType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for SemanticSurfaceType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_BOUNDARIES: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_BOUNDARIES: u8 = 7;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_BOUNDARIES: [Boundaries; 8] = [
  Boundaries::NONE,
  Boundaries::MultiPoint,
  Boundaries::MultiLineString,
  Boundaries::MultiSurface,
  Boundaries::CompositeSurface,
  Boundaries::Solid,
  Boundaries::MultiSolid,
  Boundaries::CompositeSolid,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Boundaries(pub u8);
#[allow(non_upper_case_globals)]
impl Boundaries {
  pub const NONE: Self = Self(0);
  pub const MultiPoint: Self = Self(1);
  pub const MultiLineString: Self = Self(2);
  pub const MultiSurface: Self = Self(3);
  pub const CompositeSurface: Self = Self(4);
  pub const Solid: Self = Self(5);
  pub const MultiSolid: Self = Self(6);
  pub const CompositeSolid: Self = Self(7);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 7;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::MultiPoint,
    Self::MultiLineString,
    Self::MultiSurface,
    Self::CompositeSurface,
    Self::Solid,
    Self::MultiSolid,
    Self::CompositeSolid,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::MultiPoint => Some("MultiPoint"),
      Self::MultiLineString => Some("MultiLineString"),
      Self::MultiSurface => Some("MultiSurface"),
      Self::CompositeSurface => Some("CompositeSurface"),
      Self::Solid => Some("Solid"),
      Self::MultiSolid => Some("MultiSolid"),
      Self::CompositeSolid => Some("CompositeSolid"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for Boundaries {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Boundaries {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for Boundaries {
    type Output = Boundaries;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for Boundaries {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Boundaries {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Boundaries {}
pub struct BoundariesUnionTableOffset {}

// struct Vector, aligned to 8
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct Vector(pub [u8; 24]);
impl Default for Vector { 
  fn default() -> Self { 
    Self([0; 24])
  }
}
impl core::fmt::Debug for Vector {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    f.debug_struct("Vector")
      .field("x", &self.x())
      .field("y", &self.y())
      .field("z", &self.z())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Vector {}
impl<'a> flatbuffers::Follow<'a> for Vector {
  type Inner = &'a Vector;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a Vector>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Vector {
  type Inner = &'a Vector;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<Vector>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for Vector {
    type Output = Vector;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(self as *const Vector as *const u8, Self::size());
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for Vector {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}

impl<'a> Vector {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    x: f64,
    y: f64,
    z: f64,
  ) -> Self {
    let mut s = Self([0; 24]);
    s.set_x(x);
    s.set_y(y);
    s.set_z(z);
    s
  }

  pub fn x(&self) -> f64 {
    let mut mem = core::mem::MaybeUninit::<<f64 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[0..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_x(&mut self, x: f64) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[0..].as_mut_ptr(),
        core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn y(&self) -> f64 {
    let mut mem = core::mem::MaybeUninit::<<f64 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[8..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_y(&mut self, x: f64) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[8..].as_mut_ptr(),
        core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn z(&self) -> f64 {
    let mut mem = core::mem::MaybeUninit::<<f64 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[16..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_z(&mut self, x: f64) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[16..].as_mut_ptr(),
        core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
      );
    }
  }

}

// struct Transform, aligned to 8
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct Transform(pub [u8; 48]);
impl Default for Transform { 
  fn default() -> Self { 
    Self([0; 48])
  }
}
impl core::fmt::Debug for Transform {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    f.debug_struct("Transform")
      .field("scale", &self.scale())
      .field("translate", &self.translate())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Transform {}
impl<'a> flatbuffers::Follow<'a> for Transform {
  type Inner = &'a Transform;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a Transform>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Transform {
  type Inner = &'a Transform;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<Transform>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for Transform {
    type Output = Transform;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(self as *const Transform as *const u8, Self::size());
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for Transform {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}

impl<'a> Transform {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    scale: &Vector,
    translate: &Vector,
  ) -> Self {
    let mut s = Self([0; 48]);
    s.set_scale(scale);
    s.set_translate(translate);
    s
  }

  pub fn scale(&self) -> &Vector {
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid struct in this slot
    unsafe { &*(self.0[0..].as_ptr() as *const Vector) }
  }

  #[allow(clippy::identity_op)]
  pub fn set_scale(&mut self, x: &Vector) {
    self.0[0..0 + 24].copy_from_slice(&x.0)
  }

  pub fn translate(&self) -> &Vector {
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid struct in this slot
    unsafe { &*(self.0[24..].as_ptr() as *const Vector) }
  }

  #[allow(clippy::identity_op)]
  pub fn set_translate(&mut self, x: &Vector) {
    self.0[24..24 + 24].copy_from_slice(&x.0)
  }

}

// struct GeographicalExtent, aligned to 8
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct GeographicalExtent(pub [u8; 48]);
impl Default for GeographicalExtent { 
  fn default() -> Self { 
    Self([0; 48])
  }
}
impl core::fmt::Debug for GeographicalExtent {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    f.debug_struct("GeographicalExtent")
      .field("min", &self.min())
      .field("max", &self.max())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for GeographicalExtent {}
impl<'a> flatbuffers::Follow<'a> for GeographicalExtent {
  type Inner = &'a GeographicalExtent;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a GeographicalExtent>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a GeographicalExtent {
  type Inner = &'a GeographicalExtent;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<GeographicalExtent>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for GeographicalExtent {
    type Output = GeographicalExtent;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(self as *const GeographicalExtent as *const u8, Self::size());
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for GeographicalExtent {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}

impl<'a> GeographicalExtent {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    min: &Vector,
    max: &Vector,
  ) -> Self {
    let mut s = Self([0; 48]);
    s.set_min(min);
    s.set_max(max);
    s
  }

  pub fn min(&self) -> &Vector {
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid struct in this slot
    unsafe { &*(self.0[0..].as_ptr() as *const Vector) }
  }

  #[allow(clippy::identity_op)]
  pub fn set_min(&mut self, x: &Vector) {
    self.0[0..0 + 24].copy_from_slice(&x.0)
  }

  pub fn max(&self) -> &Vector {
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid struct in this slot
    unsafe { &*(self.0[24..].as_ptr() as *const Vector) }
  }

  #[allow(clippy::identity_op)]
  pub fn set_max(&mut self, x: &Vector) {
    self.0[24..24 + 24].copy_from_slice(&x.0)
  }

}

// struct Vertex, aligned to 4
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct Vertex(pub [u8; 12]);
impl Default for Vertex { 
  fn default() -> Self { 
    Self([0; 12])
  }
}
impl core::fmt::Debug for Vertex {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    f.debug_struct("Vertex")
      .field("x", &self.x())
      .field("y", &self.y())
      .field("z", &self.z())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Vertex {}
impl<'a> flatbuffers::Follow<'a> for Vertex {
  type Inner = &'a Vertex;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a Vertex>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Vertex {
  type Inner = &'a Vertex;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<Vertex>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for Vertex {
    type Output = Vertex;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(self as *const Vertex as *const u8, Self::size());
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for Vertex {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}

impl<'a> Vertex {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    x: i32,
    y: i32,
    z: i32,
  ) -> Self {
    let mut s = Self([0; 12]);
    s.set_x(x);
    s.set_y(y);
    s.set_z(z);
    s
  }

  pub fn x(&self) -> i32 {
    let mut mem = core::mem::MaybeUninit::<<i32 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[0..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<i32 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_x(&mut self, x: i32) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[0..].as_mut_ptr(),
        core::mem::size_of::<<i32 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn y(&self) -> i32 {
    let mut mem = core::mem::MaybeUninit::<<i32 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[4..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<i32 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_y(&mut self, x: i32) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[4..].as_mut_ptr(),
        core::mem::size_of::<<i32 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn z(&self) -> i32 {
    let mut mem = core::mem::MaybeUninit::<<i32 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[8..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<i32 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_z(&mut self, x: i32) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[8..].as_mut_ptr(),
        core::mem::size_of::<<i32 as EndianScalar>::Scalar>(),
      );
    }
  }

}

pub enum ColumnOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Column<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Column<'a> {
  type Inner = Column<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Column<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_TYPE_: flatbuffers::VOffsetT = 6;
  pub const VT_TITLE: flatbuffers::VOffsetT = 8;
  pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 10;
  pub const VT_NULLABLE: flatbuffers::VOffsetT = 12;
  pub const VT_UNIQUE: flatbuffers::VOffsetT = 14;
  pub const VT_PRIMARY_KEY: flatbuffers::VOffsetT = 16;
  pub const VT_METADATA: flatbuffers::VOffsetT = 18;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Column { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ColumnArgs<'args>
  ) -> flatbuffers::WIPOffset<Column<'bldr>> {
    let mut builder = ColumnBuilder::new(_fbb);
    if let Some(x) = args.metadata { builder.add_metadata(x); }
    if let Some(x) = args.description { builder.add_description(x); }
    if let Some(x) = args.title { builder.add_title(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    builder.add_primary_key(args.primary_key);
    builder.add_unique(args.unique);
    builder.add_nullable(args.nullable);
    builder.add_type_(args.type_);
    builder.finish()
  }


  #[inline]
  pub fn name(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Column::VT_NAME, None).unwrap()}
  }
  #[inline]
  pub fn type_(&self) -> ColumnType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ColumnType>(Column::VT_TYPE_, Some(ColumnType::Byte)).unwrap()}
  }
  #[inline]
  pub fn title(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Column::VT_TITLE, None)}
  }
  #[inline]
  pub fn description(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Column::VT_DESCRIPTION, None)}
  }
  #[inline]
  pub fn nullable(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Column::VT_NULLABLE, Some(true)).unwrap()}
  }
  #[inline]
  pub fn unique(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Column::VT_UNIQUE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn primary_key(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Column::VT_PRIMARY_KEY, Some(false)).unwrap()}
  }
  #[inline]
  pub fn metadata(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Column::VT_METADATA, None)}
  }
}

impl flatbuffers::Verifiable for Column<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, true)?
     .visit_field::<ColumnType>("type_", Self::VT_TYPE_, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("title", Self::VT_TITLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("description", Self::VT_DESCRIPTION, false)?
     .visit_field::<bool>("nullable", Self::VT_NULLABLE, false)?
     .visit_field::<bool>("unique", Self::VT_UNIQUE, false)?
     .visit_field::<bool>("primary_key", Self::VT_PRIMARY_KEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("metadata", Self::VT_METADATA, false)?
     .finish();
    Ok(())
  }
}
pub struct ColumnArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: ColumnType,
    pub title: Option<flatbuffers::WIPOffset<&'a str>>,
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
    pub nullable: bool,
    pub unique: bool,
    pub primary_key: bool,
    pub metadata: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ColumnArgs<'a> {
  #[inline]
  fn default() -> Self {
    ColumnArgs {
      name: None, // required field
      type_: ColumnType::Byte,
      title: None,
      description: None,
      nullable: true,
      unique: false,
      primary_key: false,
      metadata: None,
    }
  }
}

pub struct ColumnBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ColumnBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Column::VT_NAME, name);
  }
  #[inline]
  pub fn add_type_(&mut self, type_: ColumnType) {
    self.fbb_.push_slot::<ColumnType>(Column::VT_TYPE_, type_, ColumnType::Byte);
  }
  #[inline]
  pub fn add_title(&mut self, title: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Column::VT_TITLE, title);
  }
  #[inline]
  pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Column::VT_DESCRIPTION, description);
  }
  #[inline]
  pub fn add_nullable(&mut self, nullable: bool) {
    self.fbb_.push_slot::<bool>(Column::VT_NULLABLE, nullable, true);
  }
  #[inline]
  pub fn add_unique(&mut self, unique: bool) {
    self.fbb_.push_slot::<bool>(Column::VT_UNIQUE, unique, false);
  }
  #[inline]
  pub fn add_primary_key(&mut self, primary_key: bool) {
    self.fbb_.push_slot::<bool>(Column::VT_PRIMARY_KEY, primary_key, false);
  }
  #[inline]
  pub fn add_metadata(&mut self, metadata: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Column::VT_METADATA, metadata);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ColumnBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ColumnBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Column<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Column::VT_NAME,"name");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Column<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Column");
      ds.field("name", &self.name());
      ds.field("type_", &self.type_());
      ds.field("title", &self.title());
      ds.field("description", &self.description());
      ds.field("nullable", &self.nullable());
      ds.field("unique", &self.unique());
      ds.field("primary_key", &self.primary_key());
      ds.field("metadata", &self.metadata());
      ds.finish()
  }
}
pub enum CrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Crs<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Crs<'a> {
  type Inner = Crs<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Crs<'a> {
  pub const VT_AUTHORITY: flatbuffers::VOffsetT = 4;
  pub const VT_VERSION: flatbuffers::VOffsetT = 6;
  pub const VT_CODE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Crs { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CrsArgs<'args>
  ) -> flatbuffers::WIPOffset<Crs<'bldr>> {
    let mut builder = CrsBuilder::new(_fbb);
    builder.add_code(args.code);
    builder.add_version(args.version);
    if let Some(x) = args.authority { builder.add_authority(x); }
    builder.finish()
  }


  #[inline]
  pub fn authority(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Crs::VT_AUTHORITY, None)}
  }
  #[inline]
  pub fn version(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Crs::VT_VERSION, Some(0)).unwrap()}
  }
  #[inline]
  pub fn code(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Crs::VT_CODE, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Crs<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("authority", Self::VT_AUTHORITY, false)?
     .visit_field::<i32>("version", Self::VT_VERSION, false)?
     .visit_field::<i32>("code", Self::VT_CODE, false)?
     .finish();
    Ok(())
  }
}
pub struct CrsArgs<'a> {
    pub authority: Option<flatbuffers::WIPOffset<&'a str>>,
    pub version: i32,
    pub code: i32,
}
impl<'a> Default for CrsArgs<'a> {
  #[inline]
  fn default() -> Self {
    CrsArgs {
      authority: None,
      version: 0,
      code: 0,
    }
  }
}

pub struct CrsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CrsBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_authority(&mut self, authority: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Crs::VT_AUTHORITY, authority);
  }
  #[inline]
  pub fn add_version(&mut self, version: i32) {
    self.fbb_.push_slot::<i32>(Crs::VT_VERSION, version, 0);
  }
  #[inline]
  pub fn add_code(&mut self, code: i32) {
    self.fbb_.push_slot::<i32>(Crs::VT_CODE, code, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CrsBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CrsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Crs<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Crs<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Crs");
      ds.field("authority", &self.authority());
      ds.field("version", &self.version());
      ds.field("code", &self.code());
      ds.finish()
  }
}
pub enum HeaderOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Header<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Header<'a> {
  type Inner = Header<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Header<'a> {
  pub const VT_GEOGRAPHICAL_EXTENT: flatbuffers::VOffsetT = 4;
  pub const VT_TRANSFORM: flatbuffers::VOffsetT = 6;
  pub const VT_COLUMNS: flatbuffers::VOffsetT = 8;
  pub const VT_FEATURES_COUNT: flatbuffers::VOffsetT = 10;
  pub const VT_CRS: flatbuffers::VOffsetT = 12;
  pub const VT_METADATA: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Header { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args HeaderArgs<'args>
  ) -> flatbuffers::WIPOffset<Header<'bldr>> {
    let mut builder = HeaderBuilder::new(_fbb);
    builder.add_features_count(args.features_count);
    if let Some(x) = args.metadata { builder.add_metadata(x); }
    if let Some(x) = args.crs { builder.add_crs(x); }
    if let Some(x) = args.columns { builder.add_columns(x); }
    if let Some(x) = args.transform { builder.add_transform(x); }
    if let Some(x) = args.geographical_extent { builder.add_geographical_extent(x); }
    builder.finish()
  }


  #[inline]
  pub fn geographical_extent(&self) -> Option<&'a GeographicalExtent> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<GeographicalExtent>(Header::VT_GEOGRAPHICAL_EXTENT, None)}
  }
  #[inline]
  pub fn transform(&self) -> Option<&'a Transform> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Transform>(Header::VT_TRANSFORM, None)}
  }
  #[inline]
  pub fn columns(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Column<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Column>>>>(Header::VT_COLUMNS, None)}
  }
  #[inline]
  pub fn features_count(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(Header::VT_FEATURES_COUNT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn crs(&self) -> Option<Crs<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Crs>>(Header::VT_CRS, None)}
  }
  #[inline]
  pub fn metadata(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Header::VT_METADATA, None)}
  }
}

impl flatbuffers::Verifiable for Header<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<GeographicalExtent>("geographical_extent", Self::VT_GEOGRAPHICAL_EXTENT, false)?
     .visit_field::<Transform>("transform", Self::VT_TRANSFORM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Column>>>>("columns", Self::VT_COLUMNS, false)?
     .visit_field::<u64>("features_count", Self::VT_FEATURES_COUNT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Crs>>("crs", Self::VT_CRS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("metadata", Self::VT_METADATA, false)?
     .finish();
    Ok(())
  }
}
pub struct HeaderArgs<'a> {
    pub geographical_extent: Option<&'a GeographicalExtent>,
    pub transform: Option<&'a Transform>,
    pub columns: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Column<'a>>>>>,
    pub features_count: u64,
    pub crs: Option<flatbuffers::WIPOffset<Crs<'a>>>,
    pub metadata: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for HeaderArgs<'a> {
  #[inline]
  fn default() -> Self {
    HeaderArgs {
      geographical_extent: None,
      transform: None,
      columns: None,
      features_count: 0,
      crs: None,
      metadata: None,
    }
  }
}

pub struct HeaderBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> HeaderBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_geographical_extent(&mut self, geographical_extent: &GeographicalExtent) {
    self.fbb_.push_slot_always::<&GeographicalExtent>(Header::VT_GEOGRAPHICAL_EXTENT, geographical_extent);
  }
  #[inline]
  pub fn add_transform(&mut self, transform: &Transform) {
    self.fbb_.push_slot_always::<&Transform>(Header::VT_TRANSFORM, transform);
  }
  #[inline]
  pub fn add_columns(&mut self, columns: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Column<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Header::VT_COLUMNS, columns);
  }
  #[inline]
  pub fn add_features_count(&mut self, features_count: u64) {
    self.fbb_.push_slot::<u64>(Header::VT_FEATURES_COUNT, features_count, 0);
  }
  #[inline]
  pub fn add_crs(&mut self, crs: flatbuffers::WIPOffset<Crs<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Crs>>(Header::VT_CRS, crs);
  }
  #[inline]
  pub fn add_metadata(&mut self, metadata: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Header::VT_METADATA, metadata);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> HeaderBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    HeaderBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Header<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Header<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Header");
      ds.field("geographical_extent", &self.geographical_extent());
      ds.field("transform", &self.transform());
      ds.field("columns", &self.columns());
      ds.field("features_count", &self.features_count());
      ds.field("crs", &self.crs());
      ds.field("metadata", &self.metadata());
      ds.finish()
  }
}
pub enum CityFBFeatureOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CityFBFeature<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CityFBFeature<'a> {
  type Inner = CityFBFeature<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CityFBFeature<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_OBJECTS: flatbuffers::VOffsetT = 6;
  pub const VT_VERTICES: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CityFBFeature { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CityFBFeatureArgs<'args>
  ) -> flatbuffers::WIPOffset<CityFBFeature<'bldr>> {
    let mut builder = CityFBFeatureBuilder::new(_fbb);
    if let Some(x) = args.vertices { builder.add_vertices(x); }
    if let Some(x) = args.objects { builder.add_objects(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CityFBFeature::VT_ID, None)}
  }
  #[inline]
  pub fn objects(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CityObject<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CityObject>>>>(CityFBFeature::VT_OBJECTS, None)}
  }
  #[inline]
  pub fn vertices(&self) -> Option<flatbuffers::Vector<'a, Vertex>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, Vertex>>>(CityFBFeature::VT_VERTICES, None)}
  }
}

impl flatbuffers::Verifiable for CityFBFeature<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<CityObject>>>>("objects", Self::VT_OBJECTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, Vertex>>>("vertices", Self::VT_VERTICES, false)?
     .finish();
    Ok(())
  }
}
pub struct CityFBFeatureArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub objects: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CityObject<'a>>>>>,
    pub vertices: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, Vertex>>>,
}
impl<'a> Default for CityFBFeatureArgs<'a> {
  #[inline]
  fn default() -> Self {
    CityFBFeatureArgs {
      id: None,
      objects: None,
      vertices: None,
    }
  }
}

pub struct CityFBFeatureBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CityFBFeatureBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CityFBFeature::VT_ID, id);
  }
  #[inline]
  pub fn add_objects(&mut self, objects: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<CityObject<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CityFBFeature::VT_OBJECTS, objects);
  }
  #[inline]
  pub fn add_vertices(&mut self, vertices: flatbuffers::WIPOffset<flatbuffers::Vector<'b , Vertex>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CityFBFeature::VT_VERTICES, vertices);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CityFBFeatureBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CityFBFeatureBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CityFBFeature<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CityFBFeature<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CityFBFeature");
      ds.field("id", &self.id());
      ds.field("objects", &self.objects());
      ds.field("vertices", &self.vertices());
      ds.finish()
  }
}
pub enum CityObjectOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CityObject<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CityObject<'a> {
  type Inner = CityObject<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CityObject<'a> {
  pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
  pub const VT_ID: flatbuffers::VOffsetT = 6;
  pub const VT_GEOGRAPHICAL_EXTENT: flatbuffers::VOffsetT = 8;
  pub const VT_GEOMETRY: flatbuffers::VOffsetT = 10;
  pub const VT_ATTRIBUTES: flatbuffers::VOffsetT = 12;
  pub const VT_COLUMNS: flatbuffers::VOffsetT = 14;
  pub const VT_CHILDREN: flatbuffers::VOffsetT = 16;
  pub const VT_PARENTS: flatbuffers::VOffsetT = 18;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CityObject { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CityObjectArgs<'args>
  ) -> flatbuffers::WIPOffset<CityObject<'bldr>> {
    let mut builder = CityObjectBuilder::new(_fbb);
    if let Some(x) = args.parents { builder.add_parents(x); }
    if let Some(x) = args.children { builder.add_children(x); }
    if let Some(x) = args.columns { builder.add_columns(x); }
    if let Some(x) = args.attributes { builder.add_attributes(x); }
    if let Some(x) = args.geometry { builder.add_geometry(x); }
    if let Some(x) = args.geographical_extent { builder.add_geographical_extent(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.add_type_(args.type_);
    builder.finish()
  }


  #[inline]
  pub fn type_(&self) -> CityObjectType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<CityObjectType>(CityObject::VT_TYPE_, Some(CityObjectType::Bridge)).unwrap()}
  }
  #[inline]
  pub fn id(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CityObject::VT_ID, None).unwrap()}
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &CityObject) -> bool {
    self.id() < o.id()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: & str) -> ::core::cmp::Ordering {
    let key = self.id();
    key.cmp(val)
  }
  #[inline]
  pub fn geographical_extent(&self) -> Option<&'a GeographicalExtent> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<GeographicalExtent>(CityObject::VT_GEOGRAPHICAL_EXTENT, None)}
  }
  #[inline]
  pub fn geometry(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Geometry<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Geometry>>>>(CityObject::VT_GEOMETRY, None)}
  }
  #[inline]
  pub fn attributes(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(CityObject::VT_ATTRIBUTES, None)}
  }
  #[inline]
  pub fn columns(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Column<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Column>>>>(CityObject::VT_COLUMNS, None)}
  }
  #[inline]
  pub fn children(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(CityObject::VT_CHILDREN, None)}
  }
  #[inline]
  pub fn parents(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(CityObject::VT_PARENTS, None)}
  }
}

impl flatbuffers::Verifiable for CityObject<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<CityObjectType>("type_", Self::VT_TYPE_, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, true)?
     .visit_field::<GeographicalExtent>("geographical_extent", Self::VT_GEOGRAPHICAL_EXTENT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Geometry>>>>("geometry", Self::VT_GEOMETRY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("attributes", Self::VT_ATTRIBUTES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Column>>>>("columns", Self::VT_COLUMNS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("children", Self::VT_CHILDREN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("parents", Self::VT_PARENTS, false)?
     .finish();
    Ok(())
  }
}
pub struct CityObjectArgs<'a> {
    pub type_: CityObjectType,
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub geographical_extent: Option<&'a GeographicalExtent>,
    pub geometry: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Geometry<'a>>>>>,
    pub attributes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub columns: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Column<'a>>>>>,
    pub children: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub parents: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for CityObjectArgs<'a> {
  #[inline]
  fn default() -> Self {
    CityObjectArgs {
      type_: CityObjectType::Bridge,
      id: None, // required field
      geographical_extent: None,
      geometry: None,
      attributes: None,
      columns: None,
      children: None,
      parents: None,
    }
  }
}

pub struct CityObjectBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CityObjectBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_type_(&mut self, type_: CityObjectType) {
    self.fbb_.push_slot::<CityObjectType>(CityObject::VT_TYPE_, type_, CityObjectType::Bridge);
  }
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CityObject::VT_ID, id);
  }
  #[inline]
  pub fn add_geographical_extent(&mut self, geographical_extent: &GeographicalExtent) {
    self.fbb_.push_slot_always::<&GeographicalExtent>(CityObject::VT_GEOGRAPHICAL_EXTENT, geographical_extent);
  }
  #[inline]
  pub fn add_geometry(&mut self, geometry: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Geometry<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CityObject::VT_GEOMETRY, geometry);
  }
  #[inline]
  pub fn add_attributes(&mut self, attributes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CityObject::VT_ATTRIBUTES, attributes);
  }
  #[inline]
  pub fn add_columns(&mut self, columns: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Column<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CityObject::VT_COLUMNS, columns);
  }
  #[inline]
  pub fn add_children(&mut self, children: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CityObject::VT_CHILDREN, children);
  }
  #[inline]
  pub fn add_parents(&mut self, parents: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CityObject::VT_PARENTS, parents);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CityObjectBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CityObjectBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CityObject<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, CityObject::VT_ID,"id");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CityObject<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CityObject");
      ds.field("type_", &self.type_());
      ds.field("id", &self.id());
      ds.field("geographical_extent", &self.geographical_extent());
      ds.field("geometry", &self.geometry());
      ds.field("attributes", &self.attributes());
      ds.field("columns", &self.columns());
      ds.field("children", &self.children());
      ds.field("parents", &self.parents());
      ds.finish()
  }
}
pub enum GeometryOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Geometry<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Geometry<'a> {
  type Inner = Geometry<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Geometry<'a> {
  pub const VT_LOD: flatbuffers::VOffsetT = 4;
  pub const VT_BOUNDARIES_TYPE: flatbuffers::VOffsetT = 6;
  pub const VT_BOUNDARIES: flatbuffers::VOffsetT = 8;
  pub const VT_SEMANTICS_OBJECTS: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Geometry { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args GeometryArgs<'args>
  ) -> flatbuffers::WIPOffset<Geometry<'bldr>> {
    let mut builder = GeometryBuilder::new(_fbb);
    if let Some(x) = args.semantics_objects { builder.add_semantics_objects(x); }
    if let Some(x) = args.boundaries { builder.add_boundaries(x); }
    if let Some(x) = args.lod { builder.add_lod(x); }
    builder.add_boundaries_type(args.boundaries_type);
    builder.finish()
  }


  #[inline]
  pub fn lod(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Geometry::VT_LOD, None)}
  }
  #[inline]
  pub fn boundaries_type(&self) -> Boundaries {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Boundaries>(Geometry::VT_BOUNDARIES_TYPE, Some(Boundaries::NONE)).unwrap()}
  }
  #[inline]
  pub fn boundaries(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Geometry::VT_BOUNDARIES, None)}
  }
  #[inline]
  pub fn semantics_objects(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SemanticObject<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SemanticObject>>>>(Geometry::VT_SEMANTICS_OBJECTS, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn boundaries_as_multi_point(&self) -> Option<MultiPoint<'a>> {
    if self.boundaries_type() == Boundaries::MultiPoint {
      self.boundaries().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { MultiPoint::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn boundaries_as_multi_line_string(&self) -> Option<MultiLineString<'a>> {
    if self.boundaries_type() == Boundaries::MultiLineString {
      self.boundaries().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { MultiLineString::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn boundaries_as_multi_surface(&self) -> Option<MultiSurface<'a>> {
    if self.boundaries_type() == Boundaries::MultiSurface {
      self.boundaries().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { MultiSurface::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn boundaries_as_composite_surface(&self) -> Option<CompositeSurface<'a>> {
    if self.boundaries_type() == Boundaries::CompositeSurface {
      self.boundaries().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { CompositeSurface::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn boundaries_as_solid(&self) -> Option<Solid<'a>> {
    if self.boundaries_type() == Boundaries::Solid {
      self.boundaries().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Solid::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn boundaries_as_multi_solid(&self) -> Option<MultiSolid<'a>> {
    if self.boundaries_type() == Boundaries::MultiSolid {
      self.boundaries().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { MultiSolid::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn boundaries_as_composite_solid(&self) -> Option<CompositeSolid<'a>> {
    if self.boundaries_type() == Boundaries::CompositeSolid {
      self.boundaries().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { CompositeSolid::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for Geometry<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("lod", Self::VT_LOD, false)?
     .visit_union::<Boundaries, _>("boundaries_type", Self::VT_BOUNDARIES_TYPE, "boundaries", Self::VT_BOUNDARIES, false, |key, v, pos| {
        match key {
          Boundaries::MultiPoint => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MultiPoint>>("Boundaries::MultiPoint", pos),
          Boundaries::MultiLineString => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MultiLineString>>("Boundaries::MultiLineString", pos),
          Boundaries::MultiSurface => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MultiSurface>>("Boundaries::MultiSurface", pos),
          Boundaries::CompositeSurface => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CompositeSurface>>("Boundaries::CompositeSurface", pos),
          Boundaries::Solid => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Solid>>("Boundaries::Solid", pos),
          Boundaries::MultiSolid => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MultiSolid>>("Boundaries::MultiSolid", pos),
          Boundaries::CompositeSolid => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CompositeSolid>>("Boundaries::CompositeSolid", pos),
          _ => Ok(()),
        }
     })?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<SemanticObject>>>>("semantics_objects", Self::VT_SEMANTICS_OBJECTS, false)?
     .finish();
    Ok(())
  }
}
pub struct GeometryArgs<'a> {
    pub lod: Option<flatbuffers::WIPOffset<&'a str>>,
    pub boundaries_type: Boundaries,
    pub boundaries: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub semantics_objects: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SemanticObject<'a>>>>>,
}
impl<'a> Default for GeometryArgs<'a> {
  #[inline]
  fn default() -> Self {
    GeometryArgs {
      lod: None,
      boundaries_type: Boundaries::NONE,
      boundaries: None,
      semantics_objects: None,
    }
  }
}

pub struct GeometryBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GeometryBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_lod(&mut self, lod: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Geometry::VT_LOD, lod);
  }
  #[inline]
  pub fn add_boundaries_type(&mut self, boundaries_type: Boundaries) {
    self.fbb_.push_slot::<Boundaries>(Geometry::VT_BOUNDARIES_TYPE, boundaries_type, Boundaries::NONE);
  }
  #[inline]
  pub fn add_boundaries(&mut self, boundaries: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Geometry::VT_BOUNDARIES, boundaries);
  }
  #[inline]
  pub fn add_semantics_objects(&mut self, semantics_objects: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<SemanticObject<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Geometry::VT_SEMANTICS_OBJECTS, semantics_objects);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> GeometryBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    GeometryBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Geometry<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Geometry<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Geometry");
      ds.field("lod", &self.lod());
      ds.field("boundaries_type", &self.boundaries_type());
      match self.boundaries_type() {
        Boundaries::MultiPoint => {
          if let Some(x) = self.boundaries_as_multi_point() {
            ds.field("boundaries", &x)
          } else {
            ds.field("boundaries", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Boundaries::MultiLineString => {
          if let Some(x) = self.boundaries_as_multi_line_string() {
            ds.field("boundaries", &x)
          } else {
            ds.field("boundaries", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Boundaries::MultiSurface => {
          if let Some(x) = self.boundaries_as_multi_surface() {
            ds.field("boundaries", &x)
          } else {
            ds.field("boundaries", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Boundaries::CompositeSurface => {
          if let Some(x) = self.boundaries_as_composite_surface() {
            ds.field("boundaries", &x)
          } else {
            ds.field("boundaries", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Boundaries::Solid => {
          if let Some(x) = self.boundaries_as_solid() {
            ds.field("boundaries", &x)
          } else {
            ds.field("boundaries", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Boundaries::MultiSolid => {
          if let Some(x) = self.boundaries_as_multi_solid() {
            ds.field("boundaries", &x)
          } else {
            ds.field("boundaries", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Boundaries::CompositeSolid => {
          if let Some(x) = self.boundaries_as_composite_solid() {
            ds.field("boundaries", &x)
          } else {
            ds.field("boundaries", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("boundaries", &x)
        },
      };
      ds.field("semantics_objects", &self.semantics_objects());
      ds.finish()
  }
}
pub enum PointOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Point<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Point<'a> {
  type Inner = Point<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Point<'a> {
  pub const VT_INDEX: flatbuffers::VOffsetT = 4;
  pub const VT_SEMANTIC_OBJECT_ID: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Point { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args PointArgs
  ) -> flatbuffers::WIPOffset<Point<'bldr>> {
    let mut builder = PointBuilder::new(_fbb);
    builder.add_semantic_object_id(args.semantic_object_id);
    builder.add_index(args.index);
    builder.finish()
  }


  #[inline]
  pub fn index(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(Point::VT_INDEX, Some(0)).unwrap()}
  }
  #[inline]
  pub fn semantic_object_id(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(Point::VT_SEMANTIC_OBJECT_ID, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Point<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("index", Self::VT_INDEX, false)?
     .visit_field::<u32>("semantic_object_id", Self::VT_SEMANTIC_OBJECT_ID, false)?
     .finish();
    Ok(())
  }
}
pub struct PointArgs {
    pub index: u32,
    pub semantic_object_id: u32,
}
impl<'a> Default for PointArgs {
  #[inline]
  fn default() -> Self {
    PointArgs {
      index: 0,
      semantic_object_id: 0,
    }
  }
}

pub struct PointBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PointBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_index(&mut self, index: u32) {
    self.fbb_.push_slot::<u32>(Point::VT_INDEX, index, 0);
  }
  #[inline]
  pub fn add_semantic_object_id(&mut self, semantic_object_id: u32) {
    self.fbb_.push_slot::<u32>(Point::VT_SEMANTIC_OBJECT_ID, semantic_object_id, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> PointBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    PointBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Point<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Point<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Point");
      ds.field("index", &self.index());
      ds.field("semantic_object_id", &self.semantic_object_id());
      ds.finish()
  }
}
pub enum MultiPointOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MultiPoint<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MultiPoint<'a> {
  type Inner = MultiPoint<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> MultiPoint<'a> {
  pub const VT_POINTS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MultiPoint { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args MultiPointArgs<'args>
  ) -> flatbuffers::WIPOffset<MultiPoint<'bldr>> {
    let mut builder = MultiPointBuilder::new(_fbb);
    if let Some(x) = args.points { builder.add_points(x); }
    builder.finish()
  }


  #[inline]
  pub fn points(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Point<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Point>>>>(MultiPoint::VT_POINTS, None)}
  }
}

impl flatbuffers::Verifiable for MultiPoint<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Point>>>>("points", Self::VT_POINTS, false)?
     .finish();
    Ok(())
  }
}
pub struct MultiPointArgs<'a> {
    pub points: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Point<'a>>>>>,
}
impl<'a> Default for MultiPointArgs<'a> {
  #[inline]
  fn default() -> Self {
    MultiPointArgs {
      points: None,
    }
  }
}

pub struct MultiPointBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MultiPointBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_points(&mut self, points: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Point<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MultiPoint::VT_POINTS, points);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> MultiPointBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    MultiPointBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MultiPoint<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MultiPoint<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MultiPoint");
      ds.field("points", &self.points());
      ds.finish()
  }
}
pub enum LineStringOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct LineString<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LineString<'a> {
  type Inner = LineString<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> LineString<'a> {
  pub const VT_INDICES: flatbuffers::VOffsetT = 4;
  pub const VT_SEMANTIC_OBJECT_ID: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    LineString { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args LineStringArgs<'args>
  ) -> flatbuffers::WIPOffset<LineString<'bldr>> {
    let mut builder = LineStringBuilder::new(_fbb);
    builder.add_semantic_object_id(args.semantic_object_id);
    if let Some(x) = args.indices { builder.add_indices(x); }
    builder.finish()
  }


  #[inline]
  pub fn indices(&self) -> Option<flatbuffers::Vector<'a, u32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(LineString::VT_INDICES, None)}
  }
  #[inline]
  pub fn semantic_object_id(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(LineString::VT_SEMANTIC_OBJECT_ID, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for LineString<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>("indices", Self::VT_INDICES, false)?
     .visit_field::<u32>("semantic_object_id", Self::VT_SEMANTIC_OBJECT_ID, false)?
     .finish();
    Ok(())
  }
}
pub struct LineStringArgs<'a> {
    pub indices: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub semantic_object_id: u32,
}
impl<'a> Default for LineStringArgs<'a> {
  #[inline]
  fn default() -> Self {
    LineStringArgs {
      indices: None,
      semantic_object_id: 0,
    }
  }
}

pub struct LineStringBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> LineStringBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_indices(&mut self, indices: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LineString::VT_INDICES, indices);
  }
  #[inline]
  pub fn add_semantic_object_id(&mut self, semantic_object_id: u32) {
    self.fbb_.push_slot::<u32>(LineString::VT_SEMANTIC_OBJECT_ID, semantic_object_id, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> LineStringBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    LineStringBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<LineString<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for LineString<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("LineString");
      ds.field("indices", &self.indices());
      ds.field("semantic_object_id", &self.semantic_object_id());
      ds.finish()
  }
}
pub enum MultiLineStringOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MultiLineString<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MultiLineString<'a> {
  type Inner = MultiLineString<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> MultiLineString<'a> {
  pub const VT_LINE_STRINGS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MultiLineString { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args MultiLineStringArgs<'args>
  ) -> flatbuffers::WIPOffset<MultiLineString<'bldr>> {
    let mut builder = MultiLineStringBuilder::new(_fbb);
    if let Some(x) = args.line_strings { builder.add_line_strings(x); }
    builder.finish()
  }


  #[inline]
  pub fn line_strings(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<LineString<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<LineString>>>>(MultiLineString::VT_LINE_STRINGS, None)}
  }
}

impl flatbuffers::Verifiable for MultiLineString<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<LineString>>>>("line_strings", Self::VT_LINE_STRINGS, false)?
     .finish();
    Ok(())
  }
}
pub struct MultiLineStringArgs<'a> {
    pub line_strings: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<LineString<'a>>>>>,
}
impl<'a> Default for MultiLineStringArgs<'a> {
  #[inline]
  fn default() -> Self {
    MultiLineStringArgs {
      line_strings: None,
    }
  }
}

pub struct MultiLineStringBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MultiLineStringBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_line_strings(&mut self, line_strings: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<LineString<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MultiLineString::VT_LINE_STRINGS, line_strings);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> MultiLineStringBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    MultiLineStringBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MultiLineString<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MultiLineString<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MultiLineString");
      ds.field("line_strings", &self.line_strings());
      ds.finish()
  }
}
pub enum RingOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Ring<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Ring<'a> {
  type Inner = Ring<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Ring<'a> {
  pub const VT_INDICES: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Ring { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args RingArgs<'args>
  ) -> flatbuffers::WIPOffset<Ring<'bldr>> {
    let mut builder = RingBuilder::new(_fbb);
    if let Some(x) = args.indices { builder.add_indices(x); }
    builder.finish()
  }


  #[inline]
  pub fn indices(&self) -> Option<flatbuffers::Vector<'a, u32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(Ring::VT_INDICES, None)}
  }
}

impl flatbuffers::Verifiable for Ring<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>("indices", Self::VT_INDICES, false)?
     .finish();
    Ok(())
  }
}
pub struct RingArgs<'a> {
    pub indices: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
}
impl<'a> Default for RingArgs<'a> {
  #[inline]
  fn default() -> Self {
    RingArgs {
      indices: None,
    }
  }
}

pub struct RingBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RingBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_indices(&mut self, indices: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Ring::VT_INDICES, indices);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> RingBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    RingBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Ring<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Ring<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Ring");
      ds.field("indices", &self.indices());
      ds.finish()
  }
}
pub enum SurfaceOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Surface<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Surface<'a> {
  type Inner = Surface<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Surface<'a> {
  pub const VT_RINGS: flatbuffers::VOffsetT = 4;
  pub const VT_SEMANTIC_OBJECT_ID: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Surface { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SurfaceArgs<'args>
  ) -> flatbuffers::WIPOffset<Surface<'bldr>> {
    let mut builder = SurfaceBuilder::new(_fbb);
    builder.add_semantic_object_id(args.semantic_object_id);
    if let Some(x) = args.rings { builder.add_rings(x); }
    builder.finish()
  }


  #[inline]
  pub fn rings(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Ring<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Ring>>>>(Surface::VT_RINGS, None)}
  }
  #[inline]
  pub fn semantic_object_id(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(Surface::VT_SEMANTIC_OBJECT_ID, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Surface<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Ring>>>>("rings", Self::VT_RINGS, false)?
     .visit_field::<u32>("semantic_object_id", Self::VT_SEMANTIC_OBJECT_ID, false)?
     .finish();
    Ok(())
  }
}
pub struct SurfaceArgs<'a> {
    pub rings: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Ring<'a>>>>>,
    pub semantic_object_id: u32,
}
impl<'a> Default for SurfaceArgs<'a> {
  #[inline]
  fn default() -> Self {
    SurfaceArgs {
      rings: None,
      semantic_object_id: 0,
    }
  }
}

pub struct SurfaceBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SurfaceBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_rings(&mut self, rings: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Ring<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Surface::VT_RINGS, rings);
  }
  #[inline]
  pub fn add_semantic_object_id(&mut self, semantic_object_id: u32) {
    self.fbb_.push_slot::<u32>(Surface::VT_SEMANTIC_OBJECT_ID, semantic_object_id, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SurfaceBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SurfaceBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Surface<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Surface<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Surface");
      ds.field("rings", &self.rings());
      ds.field("semantic_object_id", &self.semantic_object_id());
      ds.finish()
  }
}
pub enum MultiSurfaceOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MultiSurface<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MultiSurface<'a> {
  type Inner = MultiSurface<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> MultiSurface<'a> {
  pub const VT_SURFACES: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MultiSurface { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args MultiSurfaceArgs<'args>
  ) -> flatbuffers::WIPOffset<MultiSurface<'bldr>> {
    let mut builder = MultiSurfaceBuilder::new(_fbb);
    if let Some(x) = args.surfaces { builder.add_surfaces(x); }
    builder.finish()
  }


  #[inline]
  pub fn surfaces(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Surface<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Surface>>>>(MultiSurface::VT_SURFACES, None)}
  }
}

impl flatbuffers::Verifiable for MultiSurface<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Surface>>>>("surfaces", Self::VT_SURFACES, false)?
     .finish();
    Ok(())
  }
}
pub struct MultiSurfaceArgs<'a> {
    pub surfaces: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Surface<'a>>>>>,
}
impl<'a> Default for MultiSurfaceArgs<'a> {
  #[inline]
  fn default() -> Self {
    MultiSurfaceArgs {
      surfaces: None,
    }
  }
}

pub struct MultiSurfaceBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MultiSurfaceBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_surfaces(&mut self, surfaces: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Surface<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MultiSurface::VT_SURFACES, surfaces);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> MultiSurfaceBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    MultiSurfaceBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MultiSurface<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MultiSurface<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MultiSurface");
      ds.field("surfaces", &self.surfaces());
      ds.finish()
  }
}
pub enum CompositeSurfaceOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CompositeSurface<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CompositeSurface<'a> {
  type Inner = CompositeSurface<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CompositeSurface<'a> {
  pub const VT_SURFACES: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CompositeSurface { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CompositeSurfaceArgs<'args>
  ) -> flatbuffers::WIPOffset<CompositeSurface<'bldr>> {
    let mut builder = CompositeSurfaceBuilder::new(_fbb);
    if let Some(x) = args.surfaces { builder.add_surfaces(x); }
    builder.finish()
  }


  #[inline]
  pub fn surfaces(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Surface<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Surface>>>>(CompositeSurface::VT_SURFACES, None)}
  }
}

impl flatbuffers::Verifiable for CompositeSurface<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Surface>>>>("surfaces", Self::VT_SURFACES, false)?
     .finish();
    Ok(())
  }
}
pub struct CompositeSurfaceArgs<'a> {
    pub surfaces: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Surface<'a>>>>>,
}
impl<'a> Default for CompositeSurfaceArgs<'a> {
  #[inline]
  fn default() -> Self {
    CompositeSurfaceArgs {
      surfaces: None,
    }
  }
}

pub struct CompositeSurfaceBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CompositeSurfaceBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_surfaces(&mut self, surfaces: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Surface<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CompositeSurface::VT_SURFACES, surfaces);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CompositeSurfaceBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CompositeSurfaceBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CompositeSurface<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CompositeSurface<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CompositeSurface");
      ds.field("surfaces", &self.surfaces());
      ds.finish()
  }
}
pub enum ShellOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Shell<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Shell<'a> {
  type Inner = Shell<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Shell<'a> {
  pub const VT_SURFACES: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Shell { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ShellArgs<'args>
  ) -> flatbuffers::WIPOffset<Shell<'bldr>> {
    let mut builder = ShellBuilder::new(_fbb);
    if let Some(x) = args.surfaces { builder.add_surfaces(x); }
    builder.finish()
  }


  #[inline]
  pub fn surfaces(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Surface<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Surface>>>>(Shell::VT_SURFACES, None)}
  }
}

impl flatbuffers::Verifiable for Shell<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Surface>>>>("surfaces", Self::VT_SURFACES, false)?
     .finish();
    Ok(())
  }
}
pub struct ShellArgs<'a> {
    pub surfaces: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Surface<'a>>>>>,
}
impl<'a> Default for ShellArgs<'a> {
  #[inline]
  fn default() -> Self {
    ShellArgs {
      surfaces: None,
    }
  }
}

pub struct ShellBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ShellBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_surfaces(&mut self, surfaces: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Surface<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Shell::VT_SURFACES, surfaces);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ShellBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ShellBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Shell<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Shell<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Shell");
      ds.field("surfaces", &self.surfaces());
      ds.finish()
  }
}
pub enum SolidOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Solid<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Solid<'a> {
  type Inner = Solid<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Solid<'a> {
  pub const VT_SHELLS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Solid { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SolidArgs<'args>
  ) -> flatbuffers::WIPOffset<Solid<'bldr>> {
    let mut builder = SolidBuilder::new(_fbb);
    if let Some(x) = args.shells { builder.add_shells(x); }
    builder.finish()
  }


  #[inline]
  pub fn shells(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Shell<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Shell>>>>(Solid::VT_SHELLS, None)}
  }
}

impl flatbuffers::Verifiable for Solid<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Shell>>>>("shells", Self::VT_SHELLS, false)?
     .finish();
    Ok(())
  }
}
pub struct SolidArgs<'a> {
    pub shells: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Shell<'a>>>>>,
}
impl<'a> Default for SolidArgs<'a> {
  #[inline]
  fn default() -> Self {
    SolidArgs {
      shells: None,
    }
  }
}

pub struct SolidBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SolidBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_shells(&mut self, shells: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Shell<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Solid::VT_SHELLS, shells);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SolidBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SolidBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Solid<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Solid<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Solid");
      ds.field("shells", &self.shells());
      ds.finish()
  }
}
pub enum MultiSolidOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MultiSolid<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MultiSolid<'a> {
  type Inner = MultiSolid<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> MultiSolid<'a> {
  pub const VT_SHELLS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MultiSolid { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args MultiSolidArgs<'args>
  ) -> flatbuffers::WIPOffset<MultiSolid<'bldr>> {
    let mut builder = MultiSolidBuilder::new(_fbb);
    if let Some(x) = args.shells { builder.add_shells(x); }
    builder.finish()
  }


  #[inline]
  pub fn shells(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Solid<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Solid>>>>(MultiSolid::VT_SHELLS, None)}
  }
}

impl flatbuffers::Verifiable for MultiSolid<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Solid>>>>("shells", Self::VT_SHELLS, false)?
     .finish();
    Ok(())
  }
}
pub struct MultiSolidArgs<'a> {
    pub shells: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Solid<'a>>>>>,
}
impl<'a> Default for MultiSolidArgs<'a> {
  #[inline]
  fn default() -> Self {
    MultiSolidArgs {
      shells: None,
    }
  }
}

pub struct MultiSolidBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MultiSolidBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_shells(&mut self, shells: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Solid<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MultiSolid::VT_SHELLS, shells);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> MultiSolidBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    MultiSolidBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MultiSolid<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MultiSolid<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MultiSolid");
      ds.field("shells", &self.shells());
      ds.finish()
  }
}
pub enum CompositeSolidOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CompositeSolid<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CompositeSolid<'a> {
  type Inner = CompositeSolid<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CompositeSolid<'a> {
  pub const VT_SHELLS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CompositeSolid { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CompositeSolidArgs<'args>
  ) -> flatbuffers::WIPOffset<CompositeSolid<'bldr>> {
    let mut builder = CompositeSolidBuilder::new(_fbb);
    if let Some(x) = args.shells { builder.add_shells(x); }
    builder.finish()
  }


  #[inline]
  pub fn shells(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Solid<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Solid>>>>(CompositeSolid::VT_SHELLS, None)}
  }
}

impl flatbuffers::Verifiable for CompositeSolid<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Solid>>>>("shells", Self::VT_SHELLS, false)?
     .finish();
    Ok(())
  }
}
pub struct CompositeSolidArgs<'a> {
    pub shells: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Solid<'a>>>>>,
}
impl<'a> Default for CompositeSolidArgs<'a> {
  #[inline]
  fn default() -> Self {
    CompositeSolidArgs {
      shells: None,
    }
  }
}

pub struct CompositeSolidBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CompositeSolidBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_shells(&mut self, shells: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Solid<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CompositeSolid::VT_SHELLS, shells);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CompositeSolidBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CompositeSolidBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CompositeSolid<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CompositeSolid<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CompositeSolid");
      ds.field("shells", &self.shells());
      ds.finish()
  }
}
pub enum SemanticObjectOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SemanticObject<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SemanticObject<'a> {
  type Inner = SemanticObject<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SemanticObject<'a> {
  pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
  pub const VT_ATTRIBUTES: flatbuffers::VOffsetT = 6;
  pub const VT_CHILDREN: flatbuffers::VOffsetT = 8;
  pub const VT_PARENT: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SemanticObject { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SemanticObjectArgs<'args>
  ) -> flatbuffers::WIPOffset<SemanticObject<'bldr>> {
    let mut builder = SemanticObjectBuilder::new(_fbb);
    builder.add_parent(args.parent);
    if let Some(x) = args.children { builder.add_children(x); }
    if let Some(x) = args.attributes { builder.add_attributes(x); }
    builder.add_type_(args.type_);
    builder.finish()
  }


  #[inline]
  pub fn type_(&self) -> SemanticSurfaceType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<SemanticSurfaceType>(SemanticObject::VT_TYPE_, Some(SemanticSurfaceType::RoofSurface)).unwrap()}
  }
  #[inline]
  pub fn attributes(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(SemanticObject::VT_ATTRIBUTES, None)}
  }
  #[inline]
  pub fn children(&self) -> Option<flatbuffers::Vector<'a, u32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(SemanticObject::VT_CHILDREN, None)}
  }
  #[inline]
  pub fn parent(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(SemanticObject::VT_PARENT, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for SemanticObject<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<SemanticSurfaceType>("type_", Self::VT_TYPE_, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("attributes", Self::VT_ATTRIBUTES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>("children", Self::VT_CHILDREN, false)?
     .visit_field::<u32>("parent", Self::VT_PARENT, false)?
     .finish();
    Ok(())
  }
}
pub struct SemanticObjectArgs<'a> {
    pub type_: SemanticSurfaceType,
    pub attributes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub children: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub parent: u32,
}
impl<'a> Default for SemanticObjectArgs<'a> {
  #[inline]
  fn default() -> Self {
    SemanticObjectArgs {
      type_: SemanticSurfaceType::RoofSurface,
      attributes: None,
      children: None,
      parent: 0,
    }
  }
}

pub struct SemanticObjectBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SemanticObjectBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_type_(&mut self, type_: SemanticSurfaceType) {
    self.fbb_.push_slot::<SemanticSurfaceType>(SemanticObject::VT_TYPE_, type_, SemanticSurfaceType::RoofSurface);
  }
  #[inline]
  pub fn add_attributes(&mut self, attributes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SemanticObject::VT_ATTRIBUTES, attributes);
  }
  #[inline]
  pub fn add_children(&mut self, children: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SemanticObject::VT_CHILDREN, children);
  }
  #[inline]
  pub fn add_parent(&mut self, parent: u32) {
    self.fbb_.push_slot::<u32>(SemanticObject::VT_PARENT, parent, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SemanticObjectBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SemanticObjectBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SemanticObject<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SemanticObject<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SemanticObject");
      ds.field("type_", &self.type_());
      ds.field("attributes", &self.attributes());
      ds.field("children", &self.children());
      ds.field("parent", &self.parent());
      ds.finish()
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `CityFBFeature`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_city_fbfeature_unchecked`.
pub fn root_as_city_fbfeature(buf: &[u8]) -> Result<CityFBFeature, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<CityFBFeature>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `CityFBFeature` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_city_fbfeature_unchecked`.
pub fn size_prefixed_root_as_city_fbfeature(buf: &[u8]) -> Result<CityFBFeature, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<CityFBFeature>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `CityFBFeature` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_city_fbfeature_unchecked`.
pub fn root_as_city_fbfeature_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<CityFBFeature<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<CityFBFeature<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `CityFBFeature` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_city_fbfeature_unchecked`.
pub fn size_prefixed_root_as_city_fbfeature_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<CityFBFeature<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<CityFBFeature<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a CityFBFeature and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `CityFBFeature`.
pub unsafe fn root_as_city_fbfeature_unchecked(buf: &[u8]) -> CityFBFeature {
  flatbuffers::root_unchecked::<CityFBFeature>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed CityFBFeature and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `CityFBFeature`.
pub unsafe fn size_prefixed_root_as_city_fbfeature_unchecked(buf: &[u8]) -> CityFBFeature {
  flatbuffers::size_prefixed_root_unchecked::<CityFBFeature>(buf)
}
#[inline]
pub fn finish_city_fbfeature_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<CityFBFeature<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_city_fbfeature_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<CityFBFeature<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod flatCitybuf

