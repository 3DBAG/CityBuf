// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod city_buf_ {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_COLUMN_TYPE: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_COLUMN_TYPE: u8 = 14;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_COLUMN_TYPE: [ColumnType; 15] = [
  ColumnType::Byte,
  ColumnType::UByte,
  ColumnType::Bool,
  ColumnType::Short,
  ColumnType::UShort,
  ColumnType::Int,
  ColumnType::UInt,
  ColumnType::Long,
  ColumnType::ULong,
  ColumnType::Float,
  ColumnType::Double,
  ColumnType::String,
  ColumnType::Json,
  ColumnType::DateTime,
  ColumnType::Binary,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ColumnType(pub u8);
#[allow(non_upper_case_globals)]
impl ColumnType {
  pub const Byte: Self = Self(0);
  pub const UByte: Self = Self(1);
  pub const Bool: Self = Self(2);
  pub const Short: Self = Self(3);
  pub const UShort: Self = Self(4);
  pub const Int: Self = Self(5);
  pub const UInt: Self = Self(6);
  pub const Long: Self = Self(7);
  pub const ULong: Self = Self(8);
  pub const Float: Self = Self(9);
  pub const Double: Self = Self(10);
  pub const String: Self = Self(11);
  pub const Json: Self = Self(12);
  pub const DateTime: Self = Self(13);
  pub const Binary: Self = Self(14);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 14;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Byte,
    Self::UByte,
    Self::Bool,
    Self::Short,
    Self::UShort,
    Self::Int,
    Self::UInt,
    Self::Long,
    Self::ULong,
    Self::Float,
    Self::Double,
    Self::String,
    Self::Json,
    Self::DateTime,
    Self::Binary,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Byte => Some("Byte"),
      Self::UByte => Some("UByte"),
      Self::Bool => Some("Bool"),
      Self::Short => Some("Short"),
      Self::UShort => Some("UShort"),
      Self::Int => Some("Int"),
      Self::UInt => Some("UInt"),
      Self::Long => Some("Long"),
      Self::ULong => Some("ULong"),
      Self::Float => Some("Float"),
      Self::Double => Some("Double"),
      Self::String => Some("String"),
      Self::Json => Some("Json"),
      Self::DateTime => Some("DateTime"),
      Self::Binary => Some("Binary"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for ColumnType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for ColumnType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for ColumnType {
    type Output = ColumnType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for ColumnType {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for ColumnType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ColumnType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_CITY_OBJECT_TYPE: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_CITY_OBJECT_TYPE: u8 = 32;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_CITY_OBJECT_TYPE: [CityObjectType; 33] = [
  CityObjectType::Bridge,
  CityObjectType::BridgePart,
  CityObjectType::BridgeInstallation,
  CityObjectType::BridgeConstructiveElement,
  CityObjectType::BridgeRoom,
  CityObjectType::BridgeFurniture,
  CityObjectType::Building,
  CityObjectType::BuildingPart,
  CityObjectType::BuildingInstallation,
  CityObjectType::BuildingConstructiveElement,
  CityObjectType::BuildingFurniture,
  CityObjectType::BuildingStorey,
  CityObjectType::BuildingRoom,
  CityObjectType::BuildingUnit,
  CityObjectType::CityFurniture,
  CityObjectType::CityObjectGroup,
  CityObjectType::GenericCityObject,
  CityObjectType::LandUse,
  CityObjectType::OtherConstruction,
  CityObjectType::PlantCover,
  CityObjectType::SolitaryVegetationObject,
  CityObjectType::TINRelief,
  CityObjectType::Road,
  CityObjectType::Railway,
  CityObjectType::Waterway,
  CityObjectType::TransportSquare,
  CityObjectType::Tunnel,
  CityObjectType::TunnelPart,
  CityObjectType::TunnelInstallation,
  CityObjectType::TunnelConstructiveElement,
  CityObjectType::TunnelHollowSpace,
  CityObjectType::TunnelFurniture,
  CityObjectType::WaterBody,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct CityObjectType(pub u8);
#[allow(non_upper_case_globals)]
impl CityObjectType {
  pub const Bridge: Self = Self(0);
  pub const BridgePart: Self = Self(1);
  pub const BridgeInstallation: Self = Self(2);
  pub const BridgeConstructiveElement: Self = Self(3);
  pub const BridgeRoom: Self = Self(4);
  pub const BridgeFurniture: Self = Self(5);
  pub const Building: Self = Self(6);
  pub const BuildingPart: Self = Self(7);
  pub const BuildingInstallation: Self = Self(8);
  pub const BuildingConstructiveElement: Self = Self(9);
  pub const BuildingFurniture: Self = Self(10);
  pub const BuildingStorey: Self = Self(11);
  pub const BuildingRoom: Self = Self(12);
  pub const BuildingUnit: Self = Self(13);
  pub const CityFurniture: Self = Self(14);
  pub const CityObjectGroup: Self = Self(15);
  pub const GenericCityObject: Self = Self(16);
  pub const LandUse: Self = Self(17);
  pub const OtherConstruction: Self = Self(18);
  pub const PlantCover: Self = Self(19);
  pub const SolitaryVegetationObject: Self = Self(20);
  pub const TINRelief: Self = Self(21);
  pub const Road: Self = Self(22);
  pub const Railway: Self = Self(23);
  pub const Waterway: Self = Self(24);
  pub const TransportSquare: Self = Self(25);
  pub const Tunnel: Self = Self(26);
  pub const TunnelPart: Self = Self(27);
  pub const TunnelInstallation: Self = Self(28);
  pub const TunnelConstructiveElement: Self = Self(29);
  pub const TunnelHollowSpace: Self = Self(30);
  pub const TunnelFurniture: Self = Self(31);
  pub const WaterBody: Self = Self(32);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 32;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Bridge,
    Self::BridgePart,
    Self::BridgeInstallation,
    Self::BridgeConstructiveElement,
    Self::BridgeRoom,
    Self::BridgeFurniture,
    Self::Building,
    Self::BuildingPart,
    Self::BuildingInstallation,
    Self::BuildingConstructiveElement,
    Self::BuildingFurniture,
    Self::BuildingStorey,
    Self::BuildingRoom,
    Self::BuildingUnit,
    Self::CityFurniture,
    Self::CityObjectGroup,
    Self::GenericCityObject,
    Self::LandUse,
    Self::OtherConstruction,
    Self::PlantCover,
    Self::SolitaryVegetationObject,
    Self::TINRelief,
    Self::Road,
    Self::Railway,
    Self::Waterway,
    Self::TransportSquare,
    Self::Tunnel,
    Self::TunnelPart,
    Self::TunnelInstallation,
    Self::TunnelConstructiveElement,
    Self::TunnelHollowSpace,
    Self::TunnelFurniture,
    Self::WaterBody,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Bridge => Some("Bridge"),
      Self::BridgePart => Some("BridgePart"),
      Self::BridgeInstallation => Some("BridgeInstallation"),
      Self::BridgeConstructiveElement => Some("BridgeConstructiveElement"),
      Self::BridgeRoom => Some("BridgeRoom"),
      Self::BridgeFurniture => Some("BridgeFurniture"),
      Self::Building => Some("Building"),
      Self::BuildingPart => Some("BuildingPart"),
      Self::BuildingInstallation => Some("BuildingInstallation"),
      Self::BuildingConstructiveElement => Some("BuildingConstructiveElement"),
      Self::BuildingFurniture => Some("BuildingFurniture"),
      Self::BuildingStorey => Some("BuildingStorey"),
      Self::BuildingRoom => Some("BuildingRoom"),
      Self::BuildingUnit => Some("BuildingUnit"),
      Self::CityFurniture => Some("CityFurniture"),
      Self::CityObjectGroup => Some("CityObjectGroup"),
      Self::GenericCityObject => Some("GenericCityObject"),
      Self::LandUse => Some("LandUse"),
      Self::OtherConstruction => Some("OtherConstruction"),
      Self::PlantCover => Some("PlantCover"),
      Self::SolitaryVegetationObject => Some("SolitaryVegetationObject"),
      Self::TINRelief => Some("TINRelief"),
      Self::Road => Some("Road"),
      Self::Railway => Some("Railway"),
      Self::Waterway => Some("Waterway"),
      Self::TransportSquare => Some("TransportSquare"),
      Self::Tunnel => Some("Tunnel"),
      Self::TunnelPart => Some("TunnelPart"),
      Self::TunnelInstallation => Some("TunnelInstallation"),
      Self::TunnelConstructiveElement => Some("TunnelConstructiveElement"),
      Self::TunnelHollowSpace => Some("TunnelHollowSpace"),
      Self::TunnelFurniture => Some("TunnelFurniture"),
      Self::WaterBody => Some("WaterBody"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for CityObjectType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for CityObjectType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for CityObjectType {
    type Output = CityObjectType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for CityObjectType {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for CityObjectType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for CityObjectType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_SEMANTIC_SURFACE_TYPE: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_SEMANTIC_SURFACE_TYPE: u8 = 17;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_SEMANTIC_SURFACE_TYPE: [SemanticSurfaceType; 18] = [
  SemanticSurfaceType::RoofSurface,
  SemanticSurfaceType::GroundSurface,
  SemanticSurfaceType::WallSurface,
  SemanticSurfaceType::ClosureSurface,
  SemanticSurfaceType::OuterCeilingSurface,
  SemanticSurfaceType::OuterFloorSurface,
  SemanticSurfaceType::Window,
  SemanticSurfaceType::Door,
  SemanticSurfaceType::InteriorWallSurface,
  SemanticSurfaceType::CeilingSurface,
  SemanticSurfaceType::FloorSurface,
  SemanticSurfaceType::WaterSurface,
  SemanticSurfaceType::WaterGroundSurface,
  SemanticSurfaceType::WaterClosureSurface,
  SemanticSurfaceType::TrafficArea,
  SemanticSurfaceType::AuxiliaryTrafficArea,
  SemanticSurfaceType::TransportationMarking,
  SemanticSurfaceType::TransportationHole,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct SemanticSurfaceType(pub u8);
#[allow(non_upper_case_globals)]
impl SemanticSurfaceType {
  pub const RoofSurface: Self = Self(0);
  pub const GroundSurface: Self = Self(1);
  pub const WallSurface: Self = Self(2);
  pub const ClosureSurface: Self = Self(3);
  pub const OuterCeilingSurface: Self = Self(4);
  pub const OuterFloorSurface: Self = Self(5);
  pub const Window: Self = Self(6);
  pub const Door: Self = Self(7);
  pub const InteriorWallSurface: Self = Self(8);
  pub const CeilingSurface: Self = Self(9);
  pub const FloorSurface: Self = Self(10);
  pub const WaterSurface: Self = Self(11);
  pub const WaterGroundSurface: Self = Self(12);
  pub const WaterClosureSurface: Self = Self(13);
  pub const TrafficArea: Self = Self(14);
  pub const AuxiliaryTrafficArea: Self = Self(15);
  pub const TransportationMarking: Self = Self(16);
  pub const TransportationHole: Self = Self(17);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 17;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::RoofSurface,
    Self::GroundSurface,
    Self::WallSurface,
    Self::ClosureSurface,
    Self::OuterCeilingSurface,
    Self::OuterFloorSurface,
    Self::Window,
    Self::Door,
    Self::InteriorWallSurface,
    Self::CeilingSurface,
    Self::FloorSurface,
    Self::WaterSurface,
    Self::WaterGroundSurface,
    Self::WaterClosureSurface,
    Self::TrafficArea,
    Self::AuxiliaryTrafficArea,
    Self::TransportationMarking,
    Self::TransportationHole,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::RoofSurface => Some("RoofSurface"),
      Self::GroundSurface => Some("GroundSurface"),
      Self::WallSurface => Some("WallSurface"),
      Self::ClosureSurface => Some("ClosureSurface"),
      Self::OuterCeilingSurface => Some("OuterCeilingSurface"),
      Self::OuterFloorSurface => Some("OuterFloorSurface"),
      Self::Window => Some("Window"),
      Self::Door => Some("Door"),
      Self::InteriorWallSurface => Some("InteriorWallSurface"),
      Self::CeilingSurface => Some("CeilingSurface"),
      Self::FloorSurface => Some("FloorSurface"),
      Self::WaterSurface => Some("WaterSurface"),
      Self::WaterGroundSurface => Some("WaterGroundSurface"),
      Self::WaterClosureSurface => Some("WaterClosureSurface"),
      Self::TrafficArea => Some("TrafficArea"),
      Self::AuxiliaryTrafficArea => Some("AuxiliaryTrafficArea"),
      Self::TransportationMarking => Some("TransportationMarking"),
      Self::TransportationHole => Some("TransportationHole"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for SemanticSurfaceType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for SemanticSurfaceType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for SemanticSurfaceType {
    type Output = SemanticSurfaceType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for SemanticSurfaceType {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for SemanticSurfaceType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for SemanticSurfaceType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_GEOMETRY_TYPE: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_GEOMETRY_TYPE: u8 = 6;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_GEOMETRY_TYPE: [GeometryType; 7] = [
  GeometryType::MultiPoint,
  GeometryType::MultiLineString,
  GeometryType::MultiSurface,
  GeometryType::CompositeSurface,
  GeometryType::Solid,
  GeometryType::MultiSolid,
  GeometryType::CompositeSolid,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct GeometryType(pub u8);
#[allow(non_upper_case_globals)]
impl GeometryType {
  pub const MultiPoint: Self = Self(0);
  pub const MultiLineString: Self = Self(1);
  pub const MultiSurface: Self = Self(2);
  pub const CompositeSurface: Self = Self(3);
  pub const Solid: Self = Self(4);
  pub const MultiSolid: Self = Self(5);
  pub const CompositeSolid: Self = Self(6);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 6;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::MultiPoint,
    Self::MultiLineString,
    Self::MultiSurface,
    Self::CompositeSurface,
    Self::Solid,
    Self::MultiSolid,
    Self::CompositeSolid,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::MultiPoint => Some("MultiPoint"),
      Self::MultiLineString => Some("MultiLineString"),
      Self::MultiSurface => Some("MultiSurface"),
      Self::CompositeSurface => Some("CompositeSurface"),
      Self::Solid => Some("Solid"),
      Self::MultiSolid => Some("MultiSolid"),
      Self::CompositeSolid => Some("CompositeSolid"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for GeometryType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for GeometryType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for GeometryType {
    type Output = GeometryType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for GeometryType {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for GeometryType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for GeometryType {}
// struct Vector, aligned to 8
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct Vector(pub [u8; 24]);
impl Default for Vector { 
  fn default() -> Self { 
    Self([0; 24])
  }
}
impl core::fmt::Debug for Vector {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    f.debug_struct("Vector")
      .field("x", &self.x())
      .field("y", &self.y())
      .field("z", &self.z())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Vector {}
impl<'a> flatbuffers::Follow<'a> for Vector {
  type Inner = &'a Vector;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a Vector>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Vector {
  type Inner = &'a Vector;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<Vector>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for Vector {
    type Output = Vector;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(self as *const Vector as *const u8, Self::size());
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for Vector {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}

impl<'a> Vector {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    x: f64,
    y: f64,
    z: f64,
  ) -> Self {
    let mut s = Self([0; 24]);
    s.set_x(x);
    s.set_y(y);
    s.set_z(z);
    s
  }

  pub fn x(&self) -> f64 {
    let mut mem = core::mem::MaybeUninit::<<f64 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[0..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_x(&mut self, x: f64) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[0..].as_mut_ptr(),
        core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn y(&self) -> f64 {
    let mut mem = core::mem::MaybeUninit::<<f64 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[8..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_y(&mut self, x: f64) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[8..].as_mut_ptr(),
        core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn z(&self) -> f64 {
    let mut mem = core::mem::MaybeUninit::<<f64 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[16..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_z(&mut self, x: f64) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[16..].as_mut_ptr(),
        core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
      );
    }
  }

}

// struct Transform, aligned to 8
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct Transform(pub [u8; 48]);
impl Default for Transform { 
  fn default() -> Self { 
    Self([0; 48])
  }
}
impl core::fmt::Debug for Transform {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    f.debug_struct("Transform")
      .field("scale", &self.scale())
      .field("translate", &self.translate())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Transform {}
impl<'a> flatbuffers::Follow<'a> for Transform {
  type Inner = &'a Transform;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a Transform>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Transform {
  type Inner = &'a Transform;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<Transform>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for Transform {
    type Output = Transform;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(self as *const Transform as *const u8, Self::size());
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for Transform {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}

impl<'a> Transform {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    scale: &Vector,
    translate: &Vector,
  ) -> Self {
    let mut s = Self([0; 48]);
    s.set_scale(scale);
    s.set_translate(translate);
    s
  }

  pub fn scale(&self) -> &Vector {
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid struct in this slot
    unsafe { &*(self.0[0..].as_ptr() as *const Vector) }
  }

  #[allow(clippy::identity_op)]
  pub fn set_scale(&mut self, x: &Vector) {
    self.0[0..0 + 24].copy_from_slice(&x.0)
  }

  pub fn translate(&self) -> &Vector {
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid struct in this slot
    unsafe { &*(self.0[24..].as_ptr() as *const Vector) }
  }

  #[allow(clippy::identity_op)]
  pub fn set_translate(&mut self, x: &Vector) {
    self.0[24..24 + 24].copy_from_slice(&x.0)
  }

}

// struct GeographicalExtent, aligned to 8
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct GeographicalExtent(pub [u8; 48]);
impl Default for GeographicalExtent { 
  fn default() -> Self { 
    Self([0; 48])
  }
}
impl core::fmt::Debug for GeographicalExtent {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    f.debug_struct("GeographicalExtent")
      .field("min", &self.min())
      .field("max", &self.max())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for GeographicalExtent {}
impl<'a> flatbuffers::Follow<'a> for GeographicalExtent {
  type Inner = &'a GeographicalExtent;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a GeographicalExtent>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a GeographicalExtent {
  type Inner = &'a GeographicalExtent;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<GeographicalExtent>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for GeographicalExtent {
    type Output = GeographicalExtent;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(self as *const GeographicalExtent as *const u8, Self::size());
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for GeographicalExtent {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}

impl<'a> GeographicalExtent {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    min: &Vector,
    max: &Vector,
  ) -> Self {
    let mut s = Self([0; 48]);
    s.set_min(min);
    s.set_max(max);
    s
  }

  pub fn min(&self) -> &Vector {
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid struct in this slot
    unsafe { &*(self.0[0..].as_ptr() as *const Vector) }
  }

  #[allow(clippy::identity_op)]
  pub fn set_min(&mut self, x: &Vector) {
    self.0[0..0 + 24].copy_from_slice(&x.0)
  }

  pub fn max(&self) -> &Vector {
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid struct in this slot
    unsafe { &*(self.0[24..].as_ptr() as *const Vector) }
  }

  #[allow(clippy::identity_op)]
  pub fn set_max(&mut self, x: &Vector) {
    self.0[24..24 + 24].copy_from_slice(&x.0)
  }

}

// struct Vertex, aligned to 4
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct Vertex(pub [u8; 12]);
impl Default for Vertex { 
  fn default() -> Self { 
    Self([0; 12])
  }
}
impl core::fmt::Debug for Vertex {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    f.debug_struct("Vertex")
      .field("x", &self.x())
      .field("y", &self.y())
      .field("z", &self.z())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Vertex {}
impl<'a> flatbuffers::Follow<'a> for Vertex {
  type Inner = &'a Vertex;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a Vertex>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Vertex {
  type Inner = &'a Vertex;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<Vertex>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for Vertex {
    type Output = Vertex;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(self as *const Vertex as *const u8, Self::size());
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for Vertex {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}

impl<'a> Vertex {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    x: i32,
    y: i32,
    z: i32,
  ) -> Self {
    let mut s = Self([0; 12]);
    s.set_x(x);
    s.set_y(y);
    s.set_z(z);
    s
  }

  pub fn x(&self) -> i32 {
    let mut mem = core::mem::MaybeUninit::<<i32 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[0..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<i32 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_x(&mut self, x: i32) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[0..].as_mut_ptr(),
        core::mem::size_of::<<i32 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn y(&self) -> i32 {
    let mut mem = core::mem::MaybeUninit::<<i32 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[4..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<i32 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_y(&mut self, x: i32) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[4..].as_mut_ptr(),
        core::mem::size_of::<<i32 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn z(&self) -> i32 {
    let mut mem = core::mem::MaybeUninit::<<i32 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[8..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<i32 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_z(&mut self, x: i32) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[8..].as_mut_ptr(),
        core::mem::size_of::<<i32 as EndianScalar>::Scalar>(),
      );
    }
  }

}

pub enum ColumnOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Column<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Column<'a> {
  type Inner = Column<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Column<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_TYPE_: flatbuffers::VOffsetT = 6;
  pub const VT_TITLE: flatbuffers::VOffsetT = 8;
  pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 10;
  pub const VT_PRECISION: flatbuffers::VOffsetT = 12;
  pub const VT_NULLABLE: flatbuffers::VOffsetT = 14;
  pub const VT_UNIQUE: flatbuffers::VOffsetT = 16;
  pub const VT_PRIMARY_KEY: flatbuffers::VOffsetT = 18;
  pub const VT_METADATA: flatbuffers::VOffsetT = 20;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Column { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ColumnArgs<'args>
  ) -> flatbuffers::WIPOffset<Column<'bldr>> {
    let mut builder = ColumnBuilder::new(_fbb);
    if let Some(x) = args.metadata { builder.add_metadata(x); }
    builder.add_precision(args.precision);
    if let Some(x) = args.description { builder.add_description(x); }
    if let Some(x) = args.title { builder.add_title(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    builder.add_primary_key(args.primary_key);
    builder.add_unique(args.unique);
    builder.add_nullable(args.nullable);
    builder.add_type_(args.type_);
    builder.finish()
  }


  #[inline]
  pub fn name(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Column::VT_NAME, None).unwrap()}
  }
  #[inline]
  pub fn type_(&self) -> ColumnType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ColumnType>(Column::VT_TYPE_, Some(ColumnType::Byte)).unwrap()}
  }
  #[inline]
  pub fn title(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Column::VT_TITLE, None)}
  }
  #[inline]
  pub fn description(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Column::VT_DESCRIPTION, None)}
  }
  #[inline]
  pub fn precision(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Column::VT_PRECISION, Some(-1)).unwrap()}
  }
  #[inline]
  pub fn nullable(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Column::VT_NULLABLE, Some(true)).unwrap()}
  }
  #[inline]
  pub fn unique(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Column::VT_UNIQUE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn primary_key(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Column::VT_PRIMARY_KEY, Some(false)).unwrap()}
  }
  #[inline]
  pub fn metadata(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Column::VT_METADATA, None)}
  }
}

impl flatbuffers::Verifiable for Column<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, true)?
     .visit_field::<ColumnType>("type_", Self::VT_TYPE_, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("title", Self::VT_TITLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("description", Self::VT_DESCRIPTION, false)?
     .visit_field::<i32>("precision", Self::VT_PRECISION, false)?
     .visit_field::<bool>("nullable", Self::VT_NULLABLE, false)?
     .visit_field::<bool>("unique", Self::VT_UNIQUE, false)?
     .visit_field::<bool>("primary_key", Self::VT_PRIMARY_KEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("metadata", Self::VT_METADATA, false)?
     .finish();
    Ok(())
  }
}
pub struct ColumnArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: ColumnType,
    pub title: Option<flatbuffers::WIPOffset<&'a str>>,
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
    pub precision: i32,
    pub nullable: bool,
    pub unique: bool,
    pub primary_key: bool,
    pub metadata: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ColumnArgs<'a> {
  #[inline]
  fn default() -> Self {
    ColumnArgs {
      name: None, // required field
      type_: ColumnType::Byte,
      title: None,
      description: None,
      precision: -1,
      nullable: true,
      unique: false,
      primary_key: false,
      metadata: None,
    }
  }
}

pub struct ColumnBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ColumnBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Column::VT_NAME, name);
  }
  #[inline]
  pub fn add_type_(&mut self, type_: ColumnType) {
    self.fbb_.push_slot::<ColumnType>(Column::VT_TYPE_, type_, ColumnType::Byte);
  }
  #[inline]
  pub fn add_title(&mut self, title: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Column::VT_TITLE, title);
  }
  #[inline]
  pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Column::VT_DESCRIPTION, description);
  }
  #[inline]
  pub fn add_precision(&mut self, precision: i32) {
    self.fbb_.push_slot::<i32>(Column::VT_PRECISION, precision, -1);
  }
  #[inline]
  pub fn add_nullable(&mut self, nullable: bool) {
    self.fbb_.push_slot::<bool>(Column::VT_NULLABLE, nullable, true);
  }
  #[inline]
  pub fn add_unique(&mut self, unique: bool) {
    self.fbb_.push_slot::<bool>(Column::VT_UNIQUE, unique, false);
  }
  #[inline]
  pub fn add_primary_key(&mut self, primary_key: bool) {
    self.fbb_.push_slot::<bool>(Column::VT_PRIMARY_KEY, primary_key, false);
  }
  #[inline]
  pub fn add_metadata(&mut self, metadata: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Column::VT_METADATA, metadata);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ColumnBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ColumnBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Column<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Column::VT_NAME,"name");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Column<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Column");
      ds.field("name", &self.name());
      ds.field("type_", &self.type_());
      ds.field("title", &self.title());
      ds.field("description", &self.description());
      ds.field("precision", &self.precision());
      ds.field("nullable", &self.nullable());
      ds.field("unique", &self.unique());
      ds.field("primary_key", &self.primary_key());
      ds.field("metadata", &self.metadata());
      ds.finish()
  }
}
pub enum CrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Crs<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Crs<'a> {
  type Inner = Crs<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Crs<'a> {
  pub const VT_AUTHORITY: flatbuffers::VOffsetT = 4;
  pub const VT_VERSION: flatbuffers::VOffsetT = 6;
  pub const VT_CODE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Crs { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CrsArgs<'args>
  ) -> flatbuffers::WIPOffset<Crs<'bldr>> {
    let mut builder = CrsBuilder::new(_fbb);
    builder.add_code(args.code);
    builder.add_version(args.version);
    if let Some(x) = args.authority { builder.add_authority(x); }
    builder.finish()
  }


  #[inline]
  pub fn authority(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Crs::VT_AUTHORITY, None)}
  }
  #[inline]
  pub fn version(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Crs::VT_VERSION, Some(0)).unwrap()}
  }
  #[inline]
  pub fn code(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Crs::VT_CODE, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Crs<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("authority", Self::VT_AUTHORITY, false)?
     .visit_field::<i32>("version", Self::VT_VERSION, false)?
     .visit_field::<i32>("code", Self::VT_CODE, false)?
     .finish();
    Ok(())
  }
}
pub struct CrsArgs<'a> {
    pub authority: Option<flatbuffers::WIPOffset<&'a str>>,
    pub version: i32,
    pub code: i32,
}
impl<'a> Default for CrsArgs<'a> {
  #[inline]
  fn default() -> Self {
    CrsArgs {
      authority: None,
      version: 0,
      code: 0,
    }
  }
}

pub struct CrsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CrsBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_authority(&mut self, authority: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Crs::VT_AUTHORITY, authority);
  }
  #[inline]
  pub fn add_version(&mut self, version: i32) {
    self.fbb_.push_slot::<i32>(Crs::VT_VERSION, version, 0);
  }
  #[inline]
  pub fn add_code(&mut self, code: i32) {
    self.fbb_.push_slot::<i32>(Crs::VT_CODE, code, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CrsBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CrsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Crs<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Crs<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Crs");
      ds.field("authority", &self.authority());
      ds.field("version", &self.version());
      ds.field("code", &self.code());
      ds.finish()
  }
}
pub enum HeaderOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Header<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Header<'a> {
  type Inner = Header<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Header<'a> {
  pub const VT_GEOGRAPHICAL_EXTENT: flatbuffers::VOffsetT = 4;
  pub const VT_TRANSFORM: flatbuffers::VOffsetT = 6;
  pub const VT_COLUMNS: flatbuffers::VOffsetT = 8;
  pub const VT_FEATURES_COUNT: flatbuffers::VOffsetT = 10;
  pub const VT_CRS: flatbuffers::VOffsetT = 12;
  pub const VT_METADATA: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Header { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args HeaderArgs<'args>
  ) -> flatbuffers::WIPOffset<Header<'bldr>> {
    let mut builder = HeaderBuilder::new(_fbb);
    builder.add_features_count(args.features_count);
    if let Some(x) = args.metadata { builder.add_metadata(x); }
    if let Some(x) = args.crs { builder.add_crs(x); }
    if let Some(x) = args.columns { builder.add_columns(x); }
    if let Some(x) = args.transform { builder.add_transform(x); }
    if let Some(x) = args.geographical_extent { builder.add_geographical_extent(x); }
    builder.finish()
  }


  #[inline]
  pub fn geographical_extent(&self) -> Option<&'a GeographicalExtent> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<GeographicalExtent>(Header::VT_GEOGRAPHICAL_EXTENT, None)}
  }
  #[inline]
  pub fn transform(&self) -> Option<&'a Transform> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Transform>(Header::VT_TRANSFORM, None)}
  }
  #[inline]
  pub fn columns(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Column<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Column>>>>(Header::VT_COLUMNS, None)}
  }
  #[inline]
  pub fn features_count(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(Header::VT_FEATURES_COUNT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn crs(&self) -> Option<Crs<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Crs>>(Header::VT_CRS, None)}
  }
  #[inline]
  pub fn metadata(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Header::VT_METADATA, None)}
  }
}

impl flatbuffers::Verifiable for Header<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<GeographicalExtent>("geographical_extent", Self::VT_GEOGRAPHICAL_EXTENT, false)?
     .visit_field::<Transform>("transform", Self::VT_TRANSFORM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Column>>>>("columns", Self::VT_COLUMNS, false)?
     .visit_field::<u64>("features_count", Self::VT_FEATURES_COUNT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Crs>>("crs", Self::VT_CRS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("metadata", Self::VT_METADATA, false)?
     .finish();
    Ok(())
  }
}
pub struct HeaderArgs<'a> {
    pub geographical_extent: Option<&'a GeographicalExtent>,
    pub transform: Option<&'a Transform>,
    pub columns: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Column<'a>>>>>,
    pub features_count: u64,
    pub crs: Option<flatbuffers::WIPOffset<Crs<'a>>>,
    pub metadata: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for HeaderArgs<'a> {
  #[inline]
  fn default() -> Self {
    HeaderArgs {
      geographical_extent: None,
      transform: None,
      columns: None,
      features_count: 0,
      crs: None,
      metadata: None,
    }
  }
}

pub struct HeaderBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> HeaderBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_geographical_extent(&mut self, geographical_extent: &GeographicalExtent) {
    self.fbb_.push_slot_always::<&GeographicalExtent>(Header::VT_GEOGRAPHICAL_EXTENT, geographical_extent);
  }
  #[inline]
  pub fn add_transform(&mut self, transform: &Transform) {
    self.fbb_.push_slot_always::<&Transform>(Header::VT_TRANSFORM, transform);
  }
  #[inline]
  pub fn add_columns(&mut self, columns: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Column<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Header::VT_COLUMNS, columns);
  }
  #[inline]
  pub fn add_features_count(&mut self, features_count: u64) {
    self.fbb_.push_slot::<u64>(Header::VT_FEATURES_COUNT, features_count, 0);
  }
  #[inline]
  pub fn add_crs(&mut self, crs: flatbuffers::WIPOffset<Crs<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Crs>>(Header::VT_CRS, crs);
  }
  #[inline]
  pub fn add_metadata(&mut self, metadata: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Header::VT_METADATA, metadata);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> HeaderBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    HeaderBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Header<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Header<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Header");
      ds.field("geographical_extent", &self.geographical_extent());
      ds.field("transform", &self.transform());
      ds.field("columns", &self.columns());
      ds.field("features_count", &self.features_count());
      ds.field("crs", &self.crs());
      ds.field("metadata", &self.metadata());
      ds.finish()
  }
}
pub enum CityFeatureOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CityFeature<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CityFeature<'a> {
  type Inner = CityFeature<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CityFeature<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_OBJECTS: flatbuffers::VOffsetT = 6;
  pub const VT_VERTICES: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CityFeature { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CityFeatureArgs<'args>
  ) -> flatbuffers::WIPOffset<CityFeature<'bldr>> {
    let mut builder = CityFeatureBuilder::new(_fbb);
    if let Some(x) = args.vertices { builder.add_vertices(x); }
    if let Some(x) = args.objects { builder.add_objects(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CityFeature::VT_ID, None).unwrap()}
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &CityFeature) -> bool {
    self.id() < o.id()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: & str) -> ::core::cmp::Ordering {
    let key = self.id();
    key.cmp(val)
  }
  #[inline]
  pub fn objects(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CityObject<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CityObject>>>>(CityFeature::VT_OBJECTS, None)}
  }
  #[inline]
  pub fn vertices(&self) -> Option<flatbuffers::Vector<'a, Vertex>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, Vertex>>>(CityFeature::VT_VERTICES, None)}
  }
}

impl flatbuffers::Verifiable for CityFeature<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<CityObject>>>>("objects", Self::VT_OBJECTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, Vertex>>>("vertices", Self::VT_VERTICES, false)?
     .finish();
    Ok(())
  }
}
pub struct CityFeatureArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub objects: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CityObject<'a>>>>>,
    pub vertices: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, Vertex>>>,
}
impl<'a> Default for CityFeatureArgs<'a> {
  #[inline]
  fn default() -> Self {
    CityFeatureArgs {
      id: None, // required field
      objects: None,
      vertices: None,
    }
  }
}

pub struct CityFeatureBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CityFeatureBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CityFeature::VT_ID, id);
  }
  #[inline]
  pub fn add_objects(&mut self, objects: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<CityObject<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CityFeature::VT_OBJECTS, objects);
  }
  #[inline]
  pub fn add_vertices(&mut self, vertices: flatbuffers::WIPOffset<flatbuffers::Vector<'b , Vertex>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CityFeature::VT_VERTICES, vertices);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CityFeatureBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CityFeatureBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CityFeature<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, CityFeature::VT_ID,"id");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CityFeature<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CityFeature");
      ds.field("id", &self.id());
      ds.field("objects", &self.objects());
      ds.field("vertices", &self.vertices());
      ds.finish()
  }
}
pub enum CityObjectOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CityObject<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CityObject<'a> {
  type Inner = CityObject<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CityObject<'a> {
  pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
  pub const VT_ID: flatbuffers::VOffsetT = 6;
  pub const VT_GEOGRAPHICAL_EXTENT: flatbuffers::VOffsetT = 8;
  pub const VT_GEOMETRY: flatbuffers::VOffsetT = 10;
  pub const VT_ATTRIBUTES: flatbuffers::VOffsetT = 12;
  pub const VT_COLUMNS: flatbuffers::VOffsetT = 14;
  pub const VT_CHILDREN: flatbuffers::VOffsetT = 16;
  pub const VT_CHILDREN_ROLES: flatbuffers::VOffsetT = 18;
  pub const VT_PARENTS: flatbuffers::VOffsetT = 20;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CityObject { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CityObjectArgs<'args>
  ) -> flatbuffers::WIPOffset<CityObject<'bldr>> {
    let mut builder = CityObjectBuilder::new(_fbb);
    if let Some(x) = args.parents { builder.add_parents(x); }
    if let Some(x) = args.children_roles { builder.add_children_roles(x); }
    if let Some(x) = args.children { builder.add_children(x); }
    if let Some(x) = args.columns { builder.add_columns(x); }
    if let Some(x) = args.attributes { builder.add_attributes(x); }
    if let Some(x) = args.geometry { builder.add_geometry(x); }
    if let Some(x) = args.geographical_extent { builder.add_geographical_extent(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.add_type_(args.type_);
    builder.finish()
  }


  #[inline]
  pub fn type_(&self) -> CityObjectType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<CityObjectType>(CityObject::VT_TYPE_, Some(CityObjectType::Bridge)).unwrap()}
  }
  #[inline]
  pub fn id(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CityObject::VT_ID, None).unwrap()}
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &CityObject) -> bool {
    self.id() < o.id()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: & str) -> ::core::cmp::Ordering {
    let key = self.id();
    key.cmp(val)
  }
  #[inline]
  pub fn geographical_extent(&self) -> Option<&'a GeographicalExtent> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<GeographicalExtent>(CityObject::VT_GEOGRAPHICAL_EXTENT, None)}
  }
  #[inline]
  pub fn geometry(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Geometry<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Geometry>>>>(CityObject::VT_GEOMETRY, None)}
  }
  #[inline]
  pub fn attributes(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(CityObject::VT_ATTRIBUTES, None)}
  }
  #[inline]
  pub fn columns(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Column<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Column>>>>(CityObject::VT_COLUMNS, None)}
  }
  #[inline]
  pub fn children(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(CityObject::VT_CHILDREN, None)}
  }
  #[inline]
  pub fn children_roles(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(CityObject::VT_CHILDREN_ROLES, None)}
  }
  #[inline]
  pub fn parents(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(CityObject::VT_PARENTS, None)}
  }
}

impl flatbuffers::Verifiable for CityObject<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<CityObjectType>("type_", Self::VT_TYPE_, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, true)?
     .visit_field::<GeographicalExtent>("geographical_extent", Self::VT_GEOGRAPHICAL_EXTENT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Geometry>>>>("geometry", Self::VT_GEOMETRY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("attributes", Self::VT_ATTRIBUTES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Column>>>>("columns", Self::VT_COLUMNS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("children", Self::VT_CHILDREN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("children_roles", Self::VT_CHILDREN_ROLES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("parents", Self::VT_PARENTS, false)?
     .finish();
    Ok(())
  }
}
pub struct CityObjectArgs<'a> {
    pub type_: CityObjectType,
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub geographical_extent: Option<&'a GeographicalExtent>,
    pub geometry: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Geometry<'a>>>>>,
    pub attributes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub columns: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Column<'a>>>>>,
    pub children: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub children_roles: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub parents: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for CityObjectArgs<'a> {
  #[inline]
  fn default() -> Self {
    CityObjectArgs {
      type_: CityObjectType::Bridge,
      id: None, // required field
      geographical_extent: None,
      geometry: None,
      attributes: None,
      columns: None,
      children: None,
      children_roles: None,
      parents: None,
    }
  }
}

pub struct CityObjectBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CityObjectBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_type_(&mut self, type_: CityObjectType) {
    self.fbb_.push_slot::<CityObjectType>(CityObject::VT_TYPE_, type_, CityObjectType::Bridge);
  }
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CityObject::VT_ID, id);
  }
  #[inline]
  pub fn add_geographical_extent(&mut self, geographical_extent: &GeographicalExtent) {
    self.fbb_.push_slot_always::<&GeographicalExtent>(CityObject::VT_GEOGRAPHICAL_EXTENT, geographical_extent);
  }
  #[inline]
  pub fn add_geometry(&mut self, geometry: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Geometry<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CityObject::VT_GEOMETRY, geometry);
  }
  #[inline]
  pub fn add_attributes(&mut self, attributes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CityObject::VT_ATTRIBUTES, attributes);
  }
  #[inline]
  pub fn add_columns(&mut self, columns: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Column<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CityObject::VT_COLUMNS, columns);
  }
  #[inline]
  pub fn add_children(&mut self, children: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CityObject::VT_CHILDREN, children);
  }
  #[inline]
  pub fn add_children_roles(&mut self, children_roles: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CityObject::VT_CHILDREN_ROLES, children_roles);
  }
  #[inline]
  pub fn add_parents(&mut self, parents: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CityObject::VT_PARENTS, parents);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CityObjectBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CityObjectBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CityObject<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, CityObject::VT_ID,"id");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CityObject<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CityObject");
      ds.field("type_", &self.type_());
      ds.field("id", &self.id());
      ds.field("geographical_extent", &self.geographical_extent());
      ds.field("geometry", &self.geometry());
      ds.field("attributes", &self.attributes());
      ds.field("columns", &self.columns());
      ds.field("children", &self.children());
      ds.field("children_roles", &self.children_roles());
      ds.field("parents", &self.parents());
      ds.finish()
  }
}
pub enum GeometryOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Geometry<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Geometry<'a> {
  type Inner = Geometry<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Geometry<'a> {
  pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
  pub const VT_LOD: flatbuffers::VOffsetT = 6;
  pub const VT_SOLIDS: flatbuffers::VOffsetT = 8;
  pub const VT_SHELLS: flatbuffers::VOffsetT = 10;
  pub const VT_SURFACES: flatbuffers::VOffsetT = 12;
  pub const VT_STRINGS: flatbuffers::VOffsetT = 14;
  pub const VT_BOUNDARIES: flatbuffers::VOffsetT = 16;
  pub const VT_SEMANTICS: flatbuffers::VOffsetT = 18;
  pub const VT_SEMANTICS_OBJECTS: flatbuffers::VOffsetT = 20;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Geometry { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args GeometryArgs<'args>
  ) -> flatbuffers::WIPOffset<Geometry<'bldr>> {
    let mut builder = GeometryBuilder::new(_fbb);
    if let Some(x) = args.semantics_objects { builder.add_semantics_objects(x); }
    if let Some(x) = args.semantics { builder.add_semantics(x); }
    if let Some(x) = args.boundaries { builder.add_boundaries(x); }
    if let Some(x) = args.strings { builder.add_strings(x); }
    if let Some(x) = args.surfaces { builder.add_surfaces(x); }
    if let Some(x) = args.shells { builder.add_shells(x); }
    if let Some(x) = args.solids { builder.add_solids(x); }
    if let Some(x) = args.lod { builder.add_lod(x); }
    builder.add_type_(args.type_);
    builder.finish()
  }


  #[inline]
  pub fn type_(&self) -> GeometryType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<GeometryType>(Geometry::VT_TYPE_, Some(GeometryType::MultiPoint)).unwrap()}
  }
  #[inline]
  pub fn lod(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Geometry::VT_LOD, None)}
  }
  #[inline]
  pub fn solids(&self) -> Option<flatbuffers::Vector<'a, u32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(Geometry::VT_SOLIDS, None)}
  }
  #[inline]
  pub fn shells(&self) -> Option<flatbuffers::Vector<'a, u32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(Geometry::VT_SHELLS, None)}
  }
  #[inline]
  pub fn surfaces(&self) -> Option<flatbuffers::Vector<'a, u32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(Geometry::VT_SURFACES, None)}
  }
  #[inline]
  pub fn strings(&self) -> Option<flatbuffers::Vector<'a, u32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(Geometry::VT_STRINGS, None)}
  }
  #[inline]
  pub fn boundaries(&self) -> Option<flatbuffers::Vector<'a, u32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(Geometry::VT_BOUNDARIES, None)}
  }
  #[inline]
  pub fn semantics(&self) -> Option<flatbuffers::Vector<'a, u32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(Geometry::VT_SEMANTICS, None)}
  }
  #[inline]
  pub fn semantics_objects(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SemanticObject<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SemanticObject>>>>(Geometry::VT_SEMANTICS_OBJECTS, None)}
  }
}

impl flatbuffers::Verifiable for Geometry<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<GeometryType>("type_", Self::VT_TYPE_, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("lod", Self::VT_LOD, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>("solids", Self::VT_SOLIDS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>("shells", Self::VT_SHELLS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>("surfaces", Self::VT_SURFACES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>("strings", Self::VT_STRINGS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>("boundaries", Self::VT_BOUNDARIES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>("semantics", Self::VT_SEMANTICS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<SemanticObject>>>>("semantics_objects", Self::VT_SEMANTICS_OBJECTS, false)?
     .finish();
    Ok(())
  }
}
pub struct GeometryArgs<'a> {
    pub type_: GeometryType,
    pub lod: Option<flatbuffers::WIPOffset<&'a str>>,
    pub solids: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub shells: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub surfaces: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub strings: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub boundaries: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub semantics: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub semantics_objects: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SemanticObject<'a>>>>>,
}
impl<'a> Default for GeometryArgs<'a> {
  #[inline]
  fn default() -> Self {
    GeometryArgs {
      type_: GeometryType::MultiPoint,
      lod: None,
      solids: None,
      shells: None,
      surfaces: None,
      strings: None,
      boundaries: None,
      semantics: None,
      semantics_objects: None,
    }
  }
}

pub struct GeometryBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GeometryBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_type_(&mut self, type_: GeometryType) {
    self.fbb_.push_slot::<GeometryType>(Geometry::VT_TYPE_, type_, GeometryType::MultiPoint);
  }
  #[inline]
  pub fn add_lod(&mut self, lod: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Geometry::VT_LOD, lod);
  }
  #[inline]
  pub fn add_solids(&mut self, solids: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Geometry::VT_SOLIDS, solids);
  }
  #[inline]
  pub fn add_shells(&mut self, shells: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Geometry::VT_SHELLS, shells);
  }
  #[inline]
  pub fn add_surfaces(&mut self, surfaces: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Geometry::VT_SURFACES, surfaces);
  }
  #[inline]
  pub fn add_strings(&mut self, strings: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Geometry::VT_STRINGS, strings);
  }
  #[inline]
  pub fn add_boundaries(&mut self, boundaries: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Geometry::VT_BOUNDARIES, boundaries);
  }
  #[inline]
  pub fn add_semantics(&mut self, semantics: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Geometry::VT_SEMANTICS, semantics);
  }
  #[inline]
  pub fn add_semantics_objects(&mut self, semantics_objects: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<SemanticObject<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Geometry::VT_SEMANTICS_OBJECTS, semantics_objects);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> GeometryBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    GeometryBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Geometry<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Geometry<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Geometry");
      ds.field("type_", &self.type_());
      ds.field("lod", &self.lod());
      ds.field("solids", &self.solids());
      ds.field("shells", &self.shells());
      ds.field("surfaces", &self.surfaces());
      ds.field("strings", &self.strings());
      ds.field("boundaries", &self.boundaries());
      ds.field("semantics", &self.semantics());
      ds.field("semantics_objects", &self.semantics_objects());
      ds.finish()
  }
}
pub enum SemanticObjectOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SemanticObject<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SemanticObject<'a> {
  type Inner = SemanticObject<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SemanticObject<'a> {
  pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
  pub const VT_ATTRIBUTES: flatbuffers::VOffsetT = 6;
  pub const VT_CHILDREN: flatbuffers::VOffsetT = 8;
  pub const VT_PARENT: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SemanticObject { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SemanticObjectArgs<'args>
  ) -> flatbuffers::WIPOffset<SemanticObject<'bldr>> {
    let mut builder = SemanticObjectBuilder::new(_fbb);
    if let Some(x) = args.parent { builder.add_parent(x); }
    if let Some(x) = args.children { builder.add_children(x); }
    if let Some(x) = args.attributes { builder.add_attributes(x); }
    builder.add_type_(args.type_);
    builder.finish()
  }


  #[inline]
  pub fn type_(&self) -> SemanticSurfaceType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<SemanticSurfaceType>(SemanticObject::VT_TYPE_, Some(SemanticSurfaceType::RoofSurface)).unwrap()}
  }
  #[inline]
  pub fn attributes(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(SemanticObject::VT_ATTRIBUTES, None)}
  }
  #[inline]
  pub fn children(&self) -> Option<flatbuffers::Vector<'a, u32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(SemanticObject::VT_CHILDREN, None)}
  }
  #[inline]
  pub fn parent(&self) -> Option<u32> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(SemanticObject::VT_PARENT, None)}
  }
}

impl flatbuffers::Verifiable for SemanticObject<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<SemanticSurfaceType>("type_", Self::VT_TYPE_, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("attributes", Self::VT_ATTRIBUTES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>("children", Self::VT_CHILDREN, false)?
     .visit_field::<u32>("parent", Self::VT_PARENT, false)?
     .finish();
    Ok(())
  }
}
pub struct SemanticObjectArgs<'a> {
    pub type_: SemanticSurfaceType,
    pub attributes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub children: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub parent: Option<u32>,
}
impl<'a> Default for SemanticObjectArgs<'a> {
  #[inline]
  fn default() -> Self {
    SemanticObjectArgs {
      type_: SemanticSurfaceType::RoofSurface,
      attributes: None,
      children: None,
      parent: None,
    }
  }
}

pub struct SemanticObjectBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SemanticObjectBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_type_(&mut self, type_: SemanticSurfaceType) {
    self.fbb_.push_slot::<SemanticSurfaceType>(SemanticObject::VT_TYPE_, type_, SemanticSurfaceType::RoofSurface);
  }
  #[inline]
  pub fn add_attributes(&mut self, attributes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SemanticObject::VT_ATTRIBUTES, attributes);
  }
  #[inline]
  pub fn add_children(&mut self, children: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SemanticObject::VT_CHILDREN, children);
  }
  #[inline]
  pub fn add_parent(&mut self, parent: u32) {
    self.fbb_.push_slot_always::<u32>(SemanticObject::VT_PARENT, parent);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SemanticObjectBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SemanticObjectBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SemanticObject<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SemanticObject<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SemanticObject");
      ds.field("type_", &self.type_());
      ds.field("attributes", &self.attributes());
      ds.field("children", &self.children());
      ds.field("parent", &self.parent());
      ds.finish()
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `CityFeature`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_city_feature_unchecked`.
pub fn root_as_city_feature(buf: &[u8]) -> Result<CityFeature, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<CityFeature>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `CityFeature` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_city_feature_unchecked`.
pub fn size_prefixed_root_as_city_feature(buf: &[u8]) -> Result<CityFeature, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<CityFeature>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `CityFeature` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_city_feature_unchecked`.
pub fn root_as_city_feature_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<CityFeature<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<CityFeature<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `CityFeature` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_city_feature_unchecked`.
pub fn size_prefixed_root_as_city_feature_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<CityFeature<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<CityFeature<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a CityFeature and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `CityFeature`.
pub unsafe fn root_as_city_feature_unchecked(buf: &[u8]) -> CityFeature {
  flatbuffers::root_unchecked::<CityFeature>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed CityFeature and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `CityFeature`.
pub unsafe fn size_prefixed_root_as_city_feature_unchecked(buf: &[u8]) -> CityFeature {
  flatbuffers::size_prefixed_root_unchecked::<CityFeature>(buf)
}
#[inline]
pub fn finish_city_feature_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<CityFeature<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_city_feature_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<CityFeature<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod CityBuf_

